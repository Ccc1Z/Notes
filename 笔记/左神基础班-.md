# Day01
## 认识时间复杂度:
- 常数时间的操作:  
一个操作如果和数据量没有关系,每次都是固定时间内完成的操作,叫做常数操作。(如:数组寻址操作、加减乘除操作、位运算操作)。
- 时间复杂度为一个算法流程中,++*评价常数操作数量的指标*++。常用O(big O)来表示。在常数操作数量的表达式中,只要高阶项,不要低阶项,也不要高阶项系数,剩下的部分如果记为f(N),那么时间复杂度为O(f(N))。
- 评价一个算法流程的好坏,先看时间复杂度的指标,然后再分析不同数据样本下的实际运行时间,也就是常数项时间。
### 一个简单的理解时间复杂度的例子:
#
    一个有序数组A,另一个无序数组B,请打印B中的所有不在A中的数,A数组长度为N,B数组长度为M。
#
#
#### 算法流程1:  
    对于数组B中的每一个数,都在A中通过遍历的方式找一下：
- B->M个 / A->N个
```
for[0,M-1]{
    for[0,N-1]
}
```
-> 数组寻址是O(1)操作->总体时间复杂度O(M*N)。
#### 算法流程2:  
    对于数组B中的每一个数,都在A中通过二分的方式找一下;  
->O(M*logN) //每次砍一半,最多砍log2N次

#### 算法流程3:  
    先把数组B排序,然后用类似外排的方式打印所有不在A中出现的数。
(1):给B数组排序O(M * logM)  
(2):O(M+N)  
(3):O(M * logM)+O(M+N)
    ->N很小:O(M*logM)+O(M)
    ->M很小:O(N)

* 若A数组很短B数组很长->算法2好
* 若B数组很短A数组很长->算法3好
#

## 冒泡排序
    每一轮排序将当前的最大值放到末尾

```math
严格O(N^2)
```
```java
public class BubbleSort {
    /**
     * 冒泡排序
     *
     * @param arr 待排序数组
     * @return 排好序后的数组
     */
    public void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int end = arr.length - 1;
        for (int i = end; i > 0; i--) {
            for (int j = 0; j < end; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
    }

    /**
     * 交换
     *
     * @param arr 数组
     * @param i   数1
     * @param j   数2
     */
    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        BubbleSort bs = new BubbleSort();
        int[] arr = {3, 2, 4, 0, 7};
        bs.bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

## 选择排序
    依次把当前的最小的元素放在当前起始位置
```math
严格O(N^2)
```
```java
public class SelectionSort {
    /**
     * 选择排序
     *
     * @param arr 待排序数组
     */
    public void selectionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            }
            swap(arr,i,minIndex);
        }
    }

    /**
     * 交换
     *
     * @param arr 数组
     * @param i   索引1
     * @param j   索引2
     */
    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {3, 2, 4, 0, 7};
        SelectionSort ss = new SelectionSort();
        ss.selectionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

## 插入排序(用处大-数组长度小于60插排最快)
    类似于抓牌时,将每张牌插入到对应的位置
```math
最好情况(有序数组):O(N)

最坏情况(逆序数组):O(N^2)
```
```java
public class InsertionSort {
    /**
     * 插入排序
     *
     * @param arr 待排序数组
     */
    public void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                swap(arr, j, j + 1);
            }
        }
    }

    /**
     * 交换索引1索引2指向的数
     *
     * @param arr 数组
     * @param i   索引1
     * @param j   索引2
     */
    public void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        InsertionSort is = new InsertionSort();
        int[] arr = {3, 2, 4, 0, 7};
        is.insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
## 对数器的概念和使用(用于测试,很重要)

0.有一个你想要测得方法a  
1.实现一个绝对正确但是复杂度不好的方法b  
2.实现一个随机样本产生器  
3.实现比对的方法  
4.把方法a和方法b比对很多次来验证方法a是否正确  
5.如果有一个样本使得比对出错,打印样本分析是哪个方法出错  
6.当样本数量很多时比对测试依然正确,可以确定方法a已经正确  

    细节:  
    * 若不能保证rightMethod一定正确,打印错误的样本况来修改rigthMehtod再验证

```java
public class LogGenerator {
    /**
     * 随机数组发生器,产生一个[0,size]长度的随机数组,数值也是随机的
     * @param size 大小
     * @param value 数值
     * @return 生成的随机数组
     */
    public static int[] generateRandomArray(int size, int value) {
        /**
         * Math.random() -> double [0,1)
         * (INT)((size + 1)) * Math.random()) -> [0,size] 整数
         * size = 6, size + 1 = 7
         * Math.random() -> [0,1) * 7 -> [0,7) DOUBLE
         * double -> int [0,6] -> int
         */

        //生成长度随机的数组
        int[] arr = new int[(int) ((size + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((value + 1) * Math.random()) - (int) (value * Math.random());
        }
    return arr;
    }

    /**
     * 准备一个绝对正确的方法
     * 若系统没有,则写一个时间复杂度高容易写但绝对正确的算法
     * @param arr 数组
     */
    public static void rightMehtod(int[] arr){
        Arrays.sort(arr);
    }

    //for test
    public static int[] copyArray(int[] arr){
        if(arr == null) return null;
        int[] res = new int[arr.length];
        for(int i = 0 ; i< arr.length; i++){
            res[i] = arr[i];
        }
        return res;
    }
    //for test
    public static boolean isEqual(int[] arr1,int[] arr2){
        if((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)){
            return false;
        }
        if(arr1 == null && arr2 == null){
            return true;
        }
        if(arr1.length != arr2.length){
            return false;
        }
        for(int i = 0 ;i<arr1.length;i++){
            if(arr1[i] != arr2[i]){
                return false;
            }
        }
        return true;
    }

    //for test
    public static void main(String[] args) {
        BubbleSort bs = new BubbleSort();
        int testTime = 500000;
        int size = 10;
        int value = 100;
        boolean succeed = true;
        for(int i = 0 ; i < testTime;i++){
            int[] arr1 = generateRandomArray(size,value);
            int[] arr2 = copyArray(arr1);
            int[] arr3 = copyArray(arr1);
            bs.bubbleSort(arr1);
            rightMehtod(arr2);
            if(!isEqual(arr1,arr2)){
                succeed = false;
                System.out.println(Arrays.toString(arr1));
                System.out.println(Arrays.toString(arr2));
                System.out.println(Arrays.toString(arr3));
                break;
            }
        }
        System.out.println(succeed ? "Nice" : "Fucking fucked");
        
    }
}
```
## 剖析递归行为和递归行为时间复杂度的估算(递归函数就是系统在帮你压栈->任何递归行为都可以改成非递归)
```java
    public int recursiveGetMax(int[] arr,int l,int r){
        if(l == r){
            return arr[l];
        }
        int mid = l + ((r - l) >> 1);
        int maxLeft = recursiveGetMax(arr,l,mid);
        int maxRight = recursiveGetMax(arr,mid+1,r);
        return Math.max(maxLeft,maxRight);
    }

    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5};
        RecursiveGetMax rg = new RecursiveGetMax();
        int res = rg.recursiveGetMax(arr, 0, arr.length - 1);
        System.out.println(res);
    }
}
```
```math
    T(N) = 2*T(N/2)+O(1) 
    
    a=2,b=2,d=0  
    
    logb(a) = 1 > d
    
    O(N^1)
```
#
    一个递归的例子:  
    master公式的使用(子问题的规模是一样的)  
    T(N) = a*T(N/b)+O(N^d)
    (扩展问题:O(N*logN)怎么办,看补充阅读)
    

    T(N):样本量为N情况下的时间复杂度.
    N/b:子过程的样本量.
    a:子过程发生的次数
    O(N^d):除去调用子过程剩下步骤的代价
    
    1) logb(a) > d ->复杂度为O(N^log(b,a))  
    2) logb(a) = d ->复杂度为O(N^d * logN)  
    3) logb(a) < d ->复杂度为O(N^d)
#

## 归并排序
#
    将一个数组分成左右两个部分分别排好序,再通过外排的方式排序
    
```math
O(N*logN)

分治只考虑规模不考虑常数
```
#
```java
public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) return;
        mergeSort(arr, 0, arr.length - 1);
    }

    public static void mergeSort(int[] arr, int left, int right) {
        if (left == right) return;
        int mid = left + ((right - left) >> 1);//等同于(L+R)/2
        mergeSort(arr, left, mid);//T(N/2)
        mergeSort(arr, mid + 1, right);//T(N/2)
        merge(arr, left, mid, right);//O(N)
        //->T(N) = 2*T(N/2)+O(N)->O(N*logN)
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int[] help = new int[right - left + 1];
        int i = 0;
        int index1 = left;
        int index2 = mid + 1;
        while (index1 <= mid && index2 <= right) {
            help[i++] = arr[index1] > arr[index2] ? arr[index2++] : arr[index1++];
        }
        //第一个while结束后p1,p2必有一个越界了
        //下面两个while只会执行一个
        while (index1 <= mid) {
            help[i++] = arr[index1++];
        }
        while (index2 <= right) {
            help[i++] = arr[index2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[left + i] = help[i];
        }
    }

    public static void main(String[] args) {
        int[] arr = {6,5,4,3};
        mergeSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

### 归并排序应用(小和问题和逆序对问题)--每个小组之内的比较是没有浪费比较次数的(归并排序快的实质)

#### 小和问题  

    在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和.求一个数组的小和。  
    
    例子:
    [1,3,4,2,5]  
    1左边比1小的数 没有  
    3左边比3小的数 1  
    4左边比4小的数 1,3  
    2左边比2小的数 1  
    5左边比5小的数 1,3,4,2  
    所以小和为1+1+3+1+1+3+4+2=16
    
                res += arr[index1] < arr[index2] ? (right - index2 + 1) * arr[index1] : 0;
        在归并的过程中,如果arr[index1] < arr[index2],则从index2到right的数都比arr[index1]大,都可以构成小和.
    所以此时小和为(right - index2 +1) * arr[index1]
```java
package cn.cqu.ccc1z.review;

public class SmallSum {
    public static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) return 0;
        return mergeSort(arr, 0, arr.length - 1);
    }

    public static int mergeSort(int[] arr, int left, int right) {
        if (left == right) return 0;
        int mid = left + ((right - left) >> 1);
        return mergeSort(arr, left, mid) + mergeSort(arr, mid + 1, right) + merge(arr, left, mid, right);

    }

    public static int merge(int[] arr, int left, int mid, int right) {
        int[] help = new int[right - left + 1];
        int index1 = left;
        int index2 = mid + 1;
        int i = 0;
        int res = 0;
        while (index1 <= mid && index2 <= right) {
            res += arr[index1] < arr[index2] ? (right - index2 + 1) * arr[index1] : 0;
            help[i++] = arr[index1] < arr[index2] ? arr[index1++] : arr[index2++];
        }
        while (index1 <= mid) {
            help[i++] = arr[index1++];
        }
        while (index2 <= right) {
            help[i++] = arr[index2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[left + i] = help[i];
        }
        return res;
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 2, 5};
        System.out.println(smallSum(arr));
    }
}

```

#### 逆序对问题
    在一个数组中,左边的数如果比右边的数大,则这两个数构成一个逆序对,打印所有逆序对。
                    for(int j = index1 ; j <=mid;j++){
                    System.out.print(arr[j]+" "+arr[index2]);
                    System.out.println();
                }
    在归并的过程中,如果arr[index1] > arr[index2],则index1->mid的所有值都大于arr[index2]->都可以和arr[index2]构成逆序对
```java
package cn.cqu.ccc1z.review;

import java.util.Arrays;

public class ReverseOrder {
    public static void reverseOrder(int[] arr) {
        if(arr == null || arr.length <2){
            System.out.println("没有逆序对");
            return;
        }
        mergeSort(arr,0,arr.length-1);
    }

    public static void mergeSort(int[] arr, int left, int right) {
        if(left == right) return;
        int mid = left +((right - left)>>1);
        mergeSort(arr,left,mid);
        mergeSort(arr,mid+1,right);
        merge(arr,left,mid,right);
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int[] help = new int[right-left+1];
        int i = 0;
        int index1 = left;
        int index2 = mid+1;
        while(index1 <= mid && index2 <=right){
            if(arr[index1] > arr[index2]){
                for(int j = index1 ; j <=mid;j++){
                    System.out.print(arr[j]+" "+arr[index2]);
                    System.out.println();
                }
            }
            help[i++] = arr[index1] < arr[index2] ? arr[index1++] : arr[index2++];
        }
        while(index1 <= mid){
            help[i++] = arr[index1++];
        }
        while(index2 <= right){
            help[i++] = arr[index2++];
        }
        for(i= 0 ; i<help.length;i++){
            arr[left+i] = help[i];
        }
    }

    public static void main(String[] args) {
        int[] arr = {1,4,3,2,5};
        reverseOrder(arr);
        System.out.println(Arrays.toString(arr));
    }
}

```
# Day02
## 题目1
- 给定一个数组arr,和一个数num,请把小于等于num的数放在数组的左边,大于num的数放在数组的右边.
要求额外空间复杂度O(1),时间复杂度O(N).  
```
O(N)->遍历数组的次数时固定的

```

```
思路:在数组的最左边(left-1)位置建立一个小于等于区域
```
```java
package cn.cqu.ccc1z.day02;

import java.util.Arrays;

/**
 * 给定一个数组arr,和一个数num
 * 将小于等于num的数放在数组的左边,大于等于num的数放在数组的右边
 */
public class NetherlandsFlagI {
    public static void netherLandsFlagI(int[]arr,int num){
        int index = -1;
        for(int i = 0 ; i< arr.length;i++){
            if(arr[i] <= num){
                swap(arr,++index,i);
            }
        }
    }

    public static void swap(int[] arr,int i,int j){
//        arr[i] = arr[i] ^ arr[j];
//        arr[j] = arr[i] ^ arr[j];
//        arr[i] = arr[i] ^ arr[j];
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr ={1,8,5,3,4};
        netherLandsFlagI(arr,4);
        System.out.println(Arrays.toString(arr));
    }
}

```

---

- 荷兰国旗问题：小于num放左边,等于num放中间,大于num放右边

```
思路:(left-1)建立小于区域,(right+1)建立大于区域,cur指向当前
= num:cur->
<num:cur与小于区域下一个数交换,小于区域+1,cur++
>num:和大于区域的前一个数交换,大于区域向左扩一个位置,再考虑此时cur位置的数
如果cur == 右指针时停止
```
```java
package cn.cqu.ccc1z.day02;

import java.util.Arrays;

/**
 * 给定一个数组arr,和一个数num
 * 将小于等于num的数放在数组的左边,大于等于num的数放在数组的右边
 */
public class NetherlandsFlag {
    public static int[] partition(int[] arr,int left,int right,int num){
        int less = left-1;
        int bigger = right+1;
        while(left < bigger){
            if(arr[left] < num){
                swap(arr,++less,left++);
            }else if(arr[left] > num){
                swap(arr,--bigger,left);
            }else{
                left++;
            }
        }
        return new int[]{less+1,bigger-1};//返回的是等于区域的下标
    }

    public static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr ={1,8,5,3,4};
        int[] res = partition(arr, 0, arr.length - 1, 4);
        System.out.println(Arrays.toString(res));
        System.out.println(Arrays.toString(arr));
    }
}

```
## 快速排序
### 经典快排

```
1.将最后一个数x作为划分值,小于等于x的放在左边,大于x的放在右边
2.将两个部分分别递归到最后整体有序

经典快排每次只能搞定一个位置的数

```
### 改进快排(三路快排)
```
1.将最后一个数作为划分值,小于x的放在左边,大于x的放在右边,等于x的放在中间
2.将小于区域和大于区域递归,等于区域不需要动
```
```java
package cn.cqu.ccc1z.day02;

import java.util.Arrays;

public class QuickSort {
    public static void quickSort(int[] arr){
        if(arr == null || arr.length <2){
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr,int left,int right){
        if(left < right){
            //随机快排
            swap(arr,left + (int)(Math.random() * (right-left+1)),right);
            int[] p = partition(arr, left, right);
            quickSort(arr,left,p[0]-1);
            quickSort(arr,p[1]+1,right);
        }
    }

    public static int[] partition(int[] arr,int left,int right){
        int less = left-1;
        int bigger = right;
        while(left < bigger){
            if(arr[left] < arr[right]){
                //如果当前数小于分隔数
                //交换less+1和left数值,less++,left++
                swap(arr,++less,left++);
            }else if(arr[left] > arr[right]){
                //如果当前数大于分隔数
                //交换bigger-1和left数值,bigger-1,left不动再判断
                swap(arr,--bigger,left);
            }else{
                //如果当前数等于分隔数
                //left指向下一个位置
                left++;
            }
        }
        swap(arr,bigger,right);//因为默认最后一个数最大,最后一个数并没有参与遍历,交换后将其划分到相等部分
        return new int[] {less+1,bigger};
    }

    public static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr ={1,8,5,3,4};
        quickSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}

```
- 经典快排和三路快排时间复杂度:
```math
[1,2,3,4,5,6]->O(N^2)

[6,5,4,3,2,1]->O(N^2)

如果等于区域每次都是正正好好在中间

->大于和小于的区域刚是时N/2

->O(N*logN)
```
## 随机快排(最常用最重要的排序)
- 时间复杂度的长期期望是:
```math
时间复杂度:O(N*logN)

额外空间复杂度:O(logN)->用于记录等于(断点)的位置(p数组)->数组能够被二分多少次
```
```
在数组中随机选择(从left到right等概率选择一个数)一个数将其放在末尾作为partition进行划分
swap(arr,left + (int)(Math.random() * (right-left+1)),right);
```
```
当算法的样本不受控制时,为了绕开原始的数据状况:
    1.采用随机
    2.采用哈希
```
## 堆

==调整堆中元素的代价永远只跟堆的高度有关(O(logN))==

```
堆结构非常重要:

1.堆结构的heap insert 与 heapify
2.堆结构的增大和减少
3.如果只是建立堆的过程,时间复杂度为O(N)
4.优先级队列结构,就是堆结构
```
- 堆
- ==堆实际上是一颗完全二叉树==
    - 满二叉树:最后一层全是叶结点
    - 如果不是满二叉树,则从左到右需要依次补齐形成的树
- 用数组实现(把数组理解成一个完全二叉树)
```
    i是数组的索引
    - 左孩子:2*i+1
    - 右孩子:2*i+2
    - 父结点:i-1/2
    
    这种数组就可以脑补成一颗完全二叉树
```
### 大根堆
```
在这颗完全二叉树中任何一颗子树的最大值都是头部
```

### 小根堆
```
在这颗完全二叉树中任何一颗子树的最小值都是头部
```
### 建立大根堆->将数组变成大根堆(heap insert)
- 没进入一个结点向上调整的过程就是heapinsert的过程
```math
一个新进结点i需要比较的点数就是此时这颗完全二叉树的高度(logN)
所有点加进来的时间复杂度:

log1+log2+log3+...+log(N-1)
->收敛于O(N)

建立大根堆的时间复杂度:O(N)
```
```
i从0->n-1
如果i结点的值大于其父节点的值,则交换。
每一步都形成一个0->i的大根堆
```
```java
package cn.cqu.ccc1z.day02;

import java.util.Arrays;

public class Heap {
    /**
     * 将数组变成大根堆
     * @param arr 输入数组
     */
    public static void heap(int[] arr){
        if(arr == null || arr.length <2 ){
            return;
        }
        for(int i = 0 ; i < arr.length;i++){
            heapInsert(arr,i);
        }
    }

    /**
     * 插入第i个数形成大根堆
     * @param arr 数组
     * @param index 第i个数
     */
    public static void heapInsert(int[] arr,int index){
        while(arr[index] > arr[(index-1)/2]){
            int father = (index-1)/2;
            swap(arr,index,father);
            index = father;
        }

    }

    public static void swap(int[] arr,int i,int j){
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        int[] arr = {2,1,3,6,0,4};
        heap(arr);
        System.out.println(Arrays.toString(arr));
    }
}

```
```
 while(arr[index] > arr[(index-1)/2])
 
 arr[0]和arr[(0-1)/2]时
 (0-1)/2 == 0
```
### heapify(下沉的过程)
* 当一个节点改变时,先找其两个子孩子的最大值,再将此值与这个值比较.若小于子孩子的最大值,则下沉。
```java
    public static void heapify(int[] arr,int index,int heapSize){
        int left = index*2+1;//左孩子
        while(left < heapSize){
            int largest = left+1<heapSize && arr[left+1] > arr[left]
                    ? left+1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if(largest == index){
                break;
            }
            swap(arr,largest,index);
            index = largest;
            left = index*2+1;
        }
    }
```
#### 总结
- 向上走叫heapinsert
- 向下走叫heapify
- 一个流不断向外面吐出数,怎么样 快速求在任意时刻所有数的中位数
```
leetcode(295)
1.笨办法:准备一个容器,每吐一个数装入容器,需要求中位数时将容器排序再求其中位数。O(N*logN)

2.好方法:准备一个大根堆和一个小根堆
    如果新数小于等于大根堆的头部,该数就进大根堆
    
    如果新数大于等于小根堆的头部,该数就进小根堆
    
    如果两个堆的heapsize差值大于1,则从heapsize大的那个堆中弹出堆顶元素进另一个堆
    (弹出大根堆的操作就是将堆顶元素和大根堆的最后一个元素交换
    (heapsize的位置放堆顶元素)再变成大根堆并且heapsize-1->一个减堆的操作)
    
    最后只需要在大根堆堆顶和小根堆堆顶找到中位数即可
->
目的是想让大的N/2部分进大根堆,小的N/2部分进小根堆
```

## 堆排序
```math
时间复杂度(N*logN)

额外空间复杂度O(1)
```
- 1.让这个数组变成大根堆
- 2.把最后一个位置和堆顶位置做交换(最大值来到数组最后)
- 3.此时让堆的大小减一
- 4.让堆顶元素做heapify调整
- 5.重复2-4步骤直到heapsize = 1
```java
package cn.cqu.ccc1z.day02;

import java.util.Arrays;

public class HeapSort {
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        int heapsize = arr.length;
        //swap(arr,0,--heapsize);
        while (heapsize > 0) {
            swap(arr,0,--heapsize);
            heapify(arr, 0, heapsize);
            //swap(arr, 0, --heapsize);
        }
    }

    public static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    public static void heapify(int[] arr, int index, int heapsize) {
        int left = index * 2 + 1;
        while (left < heapsize) {
            int largest = left + 1 < heapsize && arr[left + 1] > arr[left]
                    ? left + 1 : left;
            /*注意:large = (leftChild + 1 < heapsize) && (arr[leftChild + 1] < arr[leftChild]) ? leftChild : leftChild + 1; 这样排不出来*/
            largest = arr[largest] > arr[index] ? largest : index;
            if (index == largest) {
                break;
            }
            swap(arr, index, largest);
            index = largest;
            left = index * 2 + 1;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
//        arr[i] = arr[i] ^ arr[j];
//        arr[j] = arr[i] ^ arr[j];
//        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        int[] arr = {2, 1, 3, 6, 0, 4};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}

```

# Day03

## 排序算法的稳定性及汇总

- 排序算法的稳定性是指:待排序数组中有多个相同的数,在排序结束后能否保证这些相同数的相对位置不变(如:有多个1,排序之后第一个还是第一个,第二个还是第二个....)

  - ```相同的值会不会因为一个排序算法其相对位置是否会被打乱```

  $$
  三个O(N^2)算法的稳定性(冒泡排序,选择排序,插入排序)
  $$

  

- 冒泡排序:可以做到稳定->遇到相等的值不交换,指针指向下一个数。

- 插入排序:可以做到稳定->在插入的时候遇到相等的值的时候不交换,指针指向下一个数。

- 选择排序:做不到稳定。

$$
三个O(N*logN)算法的稳定性(归并排序，快速排序，堆排序)
$$

- 归并排序:可以做到稳定->在merge的时候,遇到相等的情况,先拷贝左边的。
- 快排:做不到稳定。partition的过程做不到稳定。(论文级别的可以做到)
- 堆排:做不到稳定。heapinsert时就会破坏稳定性。

**稳定的意义:现实中的业务需要在排序的时候保留原始信息,这个时候就需要稳定(根据不同的属性进行排序,保留上一次的排序信息)**

### 工程中的综合排序算法

- 会先进行判断,数组里装的是基础类型,还是自己定义的class

- 如果装的是基础类型对象:用快排

  - 因为基础类型不用区分相等的相对位置,基础类型的相同值无差异不需要稳定性。

- 如果装的是自己定义的class对象:用归并排序

  - 需要区分相同值的相对位置，需要排序算法的稳定性。

- 如果数组长度很短(长度小于60):用插入排序(因为插入排序的常数项极低)

  - 对于样本量很大的排序,在递归的过程中,只要子问题长度小于60直接用插入排序

  ```归并排序和快速排序的终止条件是if(left == right)和if(left >= right),改进后的终止条件是if(left>right-60) return 一个插入排序```

### 有关排序问题的补充

- 归并排序的额外空间复杂度可以变成O(1),但非常难,不需要掌握,可以搜"归并排序 内部缓存法"
- 快速排序可以做到稳定性问题,但是非常难,不需要掌握,可以搜"01 stable sort"
- 有一道题目,是奇数放在数组左边,偶数放在数组右边,还要求原始的相对次序不变,碰到这个问题,可以怼面试官。

```奇偶就是0和1,通过partition来划分并且要保证原相对位置不变就是相当于让partition稳定```

### 认识比较器的使用

```java
package cn.cqu.ccc1z.zuo;

import java.util.Arrays;
import java.util.Comparator;

/**
 * 比较器的使用
 */
public class Coparator {
    public static class Student{
        private String name;
        private int id;
        private int age;

        public Student(String name,int id,int age){
            this.name = name;
            this.id = id;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", id=" + id +
                    ", age=" + age +
                    '}';
        }
    }

    public static class IdAscendingComparator implements Comparator<Student>{
        @Override
        public int compare(Student o1,Student o2){
            /**
             * 返回-1(负数):o1放在前面
             * 返回1(正数):o2放在前面
             * 返回0:两个相等
             */
            return o1.id - o2.id;
        }
    }

    public static class IdDescendingComparator implements Comparator<Student>{
        @Override
        public int compare(Student o1,Student o2){
            return o2.id - o1.id;
        }
    }

    public static void printArr(Object[] objs){
        Student[] stus = new Student[objs.length];
        for (int i = 0; i < objs.length; i++) {
            if(objs[i] instanceof Student){
                stus[i] = (Student)objs[i];
            }
        }
        for (int i = 0; i < stus.length; i++) {
            System.out.println(stus[i]);
        }
    }

    public static void main(String[] args){
        Student stu1 = new Student("A",1,12);
        Student stu2 = new Student("B",2,13);
        Student stu3 = new Student("C",3,14);
        Student[] stus = {stu3,stu2,stu1};
        System.out.println("排序前:");
        printArr(stus);
        System.out.println("===============================");
        Arrays.sort(stus,new IdAscendingComparator());
        System.out.println("按照id升序排列:");
        printArr(stus);
        System.out.println("===============================");
        System.out.println("按照id降序排列:");
        Arrays.sort(stus,new IdDescendingComparator());
        printArr(stus);
    }

}

```

### 使用比较器创建堆(优先级队列就是堆)

```java
        PriorityQueue<Student> heap = new PriorityQueue<>(new IdAscendingComparator());
//PriorityQueue<Student> heap = new PriorityQueue<>((Student o1,Student o2) -> o1.id - o2.id); lambda表达式
        heap.add(stu3);
        heap.add(stu2);
        heap.add(stu1);

        while(!heap.isEmpty()){
            Student cur = heap.poll();
            System.out.println(cur);
        }
```

### 使用比较器创建红黑树

```java
TreeSet<Student> treeMap = new TreeSet<>((Student o1, Student o2)->o1.id - o2.id);
```

### 非基于数据比较的排序(桶排序、计数排序、基数排序)

- 不是基于比较的排序就是与被排序的样本的实际数据状况很有关系,所以实际中并不经常使用。
  $$
  时间复杂度O(N)
  $$

  $$
  额外空间复杂度O(N)
  $$

- 

- 瓶颈在于取决于数据的状态

### 桶排序

- 桶就是一个容器,把每个元素加入到相应的桶中,最后再把桶内的元素倒出来。

#### 补充问题

- 给定一个数组,求排序之后,相邻两数的最大差值,要求时间复杂度O(N),且要求不能用非基于比较的排序。([3,1,6,2,7]->返回3)

  - 借用桶的概念。
  - 1.一个数组N个数,准备N+1个桶
  - 2.遍历整个数组找到最小值min,最大值max
    - 如果最小值与最大值相等,return 0

  - 如果最小值与最大值不等
    - 最小值放在0号桶里,最大值放在N号桶里
    - 将最小值到最大值这个范围等分成N+1份,这个数属于哪个范围就放在哪个桶里
      - 一个数组9个数
      - 准备10个桶(0,1,2...9)
      - 假设最小值为0,最大值为9->0放在0号桶,9放在9号桶
      - 0-9分成10份，那么5就放在5号桶里
  - N个数字N+1个桶,那么**中间必定存在一个空桶**
    - **最大差值 = 右非空桶的最小值 - 左非空桶的最大值**（错误思想-非常的错误-错的就你吗离谱）比如:
      - {19(10-19)}
      - {空}
      - {30(30-39)}
      - {49(40-49)}
      - ->最大差值是49-30而不是30-19
    - **非空桶只是为了否到最大差值来自于桶内部**
      - 只需要找进每一个桶的最大值和最小值即可
      - 每个桶的三个值:boolean(该桶是否有元素),min(进过桶的最小值),max(进过桶的最大值)。
      - **每一个非空桶的最小值都找该桶左边最近的非空桶的最大值相减记录最大差值。**

  ```java
  package cn.cqu.ccc1z.zuo;
  
  /**
   * 给定一个数组,求排序之后,相邻两数的最大差值,要求时间复杂度O(N),
   * 且要求不能用非基于比较的排序。([3,1,6,2,7]->返回3)
   */
  public class MaxGap {
      public static int maxGap(int[] nums){
          if(nums == null || nums.length < 2){
              return 0;
          }
          int len = nums.length;
          int min = Integer.MAX_VALUE;
          int max = Integer.MIN_VALUE;
          //找到数组中的最小值和最大值
          for(int i = 0 ; i < len;i++){
              min = Math.min(min,nums[i]);
              max = Math.max(max,nums[i]);
          }
          if(min == max){
              return 0;
          }
          //表示0-N号桶的三个信息
          boolean[] hasNum = new boolean[len+1];
          int[] maxs = new int[len+1];
          int[] mins = new int[len+1];
          int bid = 0;
          //更新桶的状态
          for(int i = 0 ; i < len ;i++){
              bid = bucket(nums[i],len,min,max);
              mins[bid] = hasNum[bid] ? Math.min(mins[bid],nums[i]) : nums[i];
              maxs[bid] = hasNum[bid] ? Math.max(maxs[bid],nums[i]) : nums[i];
              hasNum[bid] = true;
          }
          int res = 0;
          int lastMax = maxs[0];
          int i = 1;
          //找每一个非空桶的左边第一个非空桶
          for(;i<=len;i++){
              if(hasNum[i]){
                  res = Math.max(res,mins[i] - lastMax);
                  lastMax = maxs[i];
              }
          }
          return res;
      }
  
      /**
       * 确定第几个数放在哪个桶里
       * @param num 需要放在桶里的数
       * @param len 数组的总长度
       * @param min 数组中的最小值
       * @param max 数组中的最大值
       * @return 桶的id
       */
      public static int bucket(long num,long len,long min,long max){
          return (int)((num - min) * len / (max - min));
      }
  }
  
  ```

  ## 用数组结构实现大小固定的队列和栈

  ### 固定数组实现栈

  ```java
  package cn.cqu.ccc1z.zuo;
  
  /**
   * 数组实现栈
   */
  public class ArrayStack {
      private Integer[] arr;
      private Integer index;
  
      public ArrayStack(int initSize){
          if(initSize < 0){
              throw new IllegalArgumentException("The init size is less than 0");
          }
          arr = new Integer[initSize];
          index = 0;
      }
  
      public Integer peek(){
          if(index == 0){
              return null;
          }
          return arr[index-1];
      }
  
      public void push(int item){
          if(index == arr.length){
              throw new ArrayIndexOutOfBoundsException("The stack is full");
          }
          arr[index++] = item;
      }
  
      public Integer pop(){
          if(index == 0){
              throw new ArrayIndexOutOfBoundsException("The stack is empty");
          }
          return arr[--index];
      }
  }
  
  
  ```

  

### 固定数组实现队列

```java
package cn.cqu.ccc1z.zuo;

/**
 * 数组实现队列
 * 队首指针:start(出队使用)
 * 队尾指针:end(进队使用)
 * 当前队列大小:size
 * start与end是解耦的,但他们两个都与size耦合
 * 用size来解耦start追end的这个行为
 */
public class ArrayQueue {
    private Integer[] arr;
    private Integer size;
    private Integer start;
    private Integer end;

    public ArrayQueue(int initSize){
        if(initSize < 0 ){
            throw new IllegalArgumentException("The init size is less than 0");
        }
        arr = new Integer[initSize];
        size = 0;
        start = 0;
        end = 0;
    }

    public Integer peek(){
        if(size == 0){
            throw new RuntimeException("The queue is empty");
        }
        return arr[start];
    }

    public Integer poll(){
        if(size == 0){
            throw new RuntimeException("The queue is empty");
        }
        size--;
        int temp = start;
        start = start == arr.length - 1 ? 0 : start+1;
        return arr[temp];
    }

    public void push(Integer item){
        if(size == arr.length){
            throw new ArrayIndexOutOfBoundsException("The queue is full");
        }
        size++;
        arr[end] = item;
        end = end == arr.length-1 ? 0 : end+1;
    }
}

```

### 题目二:

- 实现一个特殊的栈,再实现栈的基本功能的基础上,再实现返回栈中最小元素的操作
- 要求
  - pop、push、getMin操作的时间复杂度都是O(1)
  - 设计的栈类型可以使用现成的栈结构
- **思路:两个栈**
  - Data栈
  - Min栈
  - 在入栈的过程中Min栈随着Data栈一起增长,当前压栈元素与Min栈栈顶元素比较,若比Min栈栈顶元素小则压入Min栈,否则就重复压入一个Min栈的栈顶。弹栈也是Data弹一个,Min弹一个。

```java
package cn.cqu.ccc1z.week1;

import java.util.Stack;

public class getMin {
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;

    public getMin(){
        this.dataStack = new Stack<>();
        this.minStack = new Stack<>();
    }

    public boolean isEmpty(){
        if(this.dataStack.isEmpty() && this.minStack.isEmpty()){
            return true
        }
        return false;
    }

    public void push(int item){
        this.dataStack.push(item);
        if(this.minStack.isEmpty()){
            this.minStack.push(item);
        }else{
            int curMin = this.minStack.peek();
            if(item < curMin){
                this.minStack.push(item);
            }else{
               this.minStack.push(curMin);
            }
        }
    }

    public Integer pop(){
        if(this.dataStack.isEmpty()){
            throw new ArrayIndexOutOfBoundsException("your stack is empty");
        }
        this.minStack.pop();
        return this.dataStack.pop();
    }

    public Integer peek(){
        if(this.dataStack.isEmpty()){
            throw new ArrayIndexOutOfBoundsException("your stack is empty");
        }
        return this.dataStack.peek();
    }

    public Integer getMin(){
        if(this.dataStack.isEmpty()){
            throw new ArrayIndexOutOfBoundsException("your stack is empty");
        }
        return this.minStack.peek();
    }
}
```

### 题目三:

- 如何仅用队列结构实现栈结构
  - 准备两个队列
    - Data队列：出列时,如果data.size() > 1 全部放入到help队列,再将那个数出队
    - help队列

```java
package cn.cqu.ccc1z.week1;

import java.util.LinkedList;
import java.util.Queue;

public class QueueStack {
    private Queue<Integer> queue;
    private Queue<Integer> help;

    public QueueStack(){
        queue = new LinkedList<>();
        help = new LinkedList<>();
    }

    public boolean isEmpty(){
        return this.queue.isEmpty();
    }

    public void push(int item){
        this.queue.add(item);
    }

    public Integer pop(){
        if(isEmpty()){
            throw new ArrayIndexOutOfBoundsException("the stack is empty");
        }
        int size = this.queue.size();
        int res = 0;
        while(size > 1){
            this.help.add(this.queue.poll());
        }
        res = queue.poll();
        swap();
        return res;
    }

    public Integer peek(){
        if(queue.isEmpty()){
            throw new ArrayIndexOutOfBoundsException("the stack is empty");
        }
        while(queue.size() != 1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }

    public  void swap(){
        Queue<Integer> temp = help;
        help = queue;
        queue = temp;

    }
}
```

- 如何仅用栈结构实现队列结构
  - 准备两个栈:先将Data栈依次出栈再依次压入到help栈中,help栈再依次出栈就是队列了
    - push栈
    - pop栈
  - 两个原则:
    - 如果push栈要往pop栈中倒元素,必须一次倒完
    - 如果pop栈中有元素那么push栈一定不能往push栈中倒

```java
package cn.cqu.ccc1z.week1;

import java.util.Stack;

public class StackArray {
    private Stack<Integer> data;
    private Stack<Integer> help;

    public StackArray(){
        data = new Stack<>();
        help = new Stack<>();
    }

    public void push(int item){
        data.push(item);
    }

    public boolean isEmpty(){
        return data.isEmpty() && help.isEmpty();
    }
    public Integer poll(){
        if(isEmpty()){
            throw new RuntimeException("the queue is empty");
        }
        dao();
        return data.pop();
    }
    public Integer peek(){
        if(isEmpty()){
            throw new RuntimeException("the queue is empty");
        }
        dao();
        return data.peek();
    }
    
    public void dao(){
        if(!help.isEmpty()){
            return;
        }else{
            while(!data.isEmpty()){
                help.push(data.pop());
            }
        }
    }
}
```

## Day04

#### 猫狗队列

- 猫狗队列 宠物、狗、猫的类如下

- ```java
  public class Pet{
      private String type;
      public Pet(String type){
          this.type = type;
      }
      public String getPetype(){
          return this.type;
      }
                  }
  
  public class Dog extends Pet{public Dog(){super("dog");}}
  public class Cat extends Pet{public Cat(){super("cat");}}
  ```

- 实现一种猫狗队列的结构，要求如下：

  - add()：将cat类或者dog类的实例放入队列中
  - pollAll()：将队列中说有的实例按照进队列的先后顺序依次弹出
  - pollDog()：将队列中dog类的实例按照进队列的先后顺序依次弹出
  - pollCat()：将队列中cat类的实例按照进队列的先后顺序依次弹出
  - isEmpty()：检查队列中是否还有dog或cat的实例
  - isDogEmpty()：检查队列中是否还有dog实例
  - isCatEmpty()：检查 队列中是否还有cat类实例

- 核心思路-新建一个类给每个Pet打上时间戳

```java
package cn.cqu.ccc1z.dayo4.zuo;

import java.util.LinkedList;
import java.util.Queue;

public class DogCatQueue {
    public static class Pet{
        private String type;
        public Pet(String type){
            this.type = type;
        }

        public String getType() {
            return this.type;
        }
    }

    public static class Dog extends Pet{
        public Dog(){
            super("dog");
        }
    }

    public static class Cat extends Pet{
        public Cat(){
            super("cat");
        }
    }

    /**
     * 自己实现一个类给宠物加上时间戳
     */
    public static class PetEnterQueue{
        private Pet pet;        //用户原有的实例
        private long count;     //时间戳

        public PetEnterQueue(Pet pet,long count){
            this.pet = pet;
            this.count = count;
        }

        public Pet getPet(){
            return this.pet;
        }

        public long getCount(){
            return this.count;
        }

        public String getEnterPetType(){
            return this.pet.getType();
        }

    }

    private Queue<PetEnterQueue> dogQ;
    private Queue<PetEnterQueue> catQ;
    private long count;

    public DogCatQueue(){
        this.dogQ = new LinkedList<>();
        this.catQ = new LinkedList<>();
        this.count = 0;
    }

    public void add(Pet pet){
        if(pet.getType().equals("dog")){
            dogQ.add(new PetEnterQueue(pet,count++));
        }else if(pet.getType().equals("cat")){
            catQ.add(new PetEnterQueue(pet,count++));
        }else{
            throw new IllegalArgumentException("wrong input");
        }
    }

    public Pet pollAll(){
        if(!dogQ.isEmpty() && !catQ.isEmpty()){
            if(dogQ.peek().getCount() < catQ.peek().getCount()){
                return dogQ.poll().getPet();
            }else{
                return catQ.poll().getPet();
            }
        }else if(!dogQ.isEmpty()){
            return dogQ.poll().getPet();
        }else if(!catQ.isEmpty()){
            return catQ.poll().getPet();
        }else{
            throw new RuntimeException("err,queue is empty");
        }
    }

    public Dog pollDog(){
        if(!dogQ.isEmpty()){
            return (Dog)dogQ.poll().getPet();
        }else{
            throw new RuntimeException("Dog queue is empty");
        }
    }

    public Cat pollCat(){
        if(!catQ.isEmpty()){
            return (Cat)catQ.poll().getPet();
        }else{
            throw new RuntimeException("Cat queue is empty");
        }
    }

    public boolean isEmpty(){
        return dogQ.isEmpty() && catQ.isEmpty();
    }

    public boolean isDogEmpty(){
        return dogQ.isEmpty();
    }

    public boolean isCatEmpty(){
        return catQ.isEmpty();
    }
}
```

### 宏观调度思想(局部位置规律不好找的时候找宏观思想)

#### 转圈打印矩阵

- 给定一个整型矩阵matrix，请按照转圈的方式打印它。
- input：
  - 1 2 3 4
  - 5 6 7 8
  - 9 10 11 12
  - 13 14 15 16
- output: 
  - 1 2 3 4 8 12 16 15 14 13 9 8 6 7 11 10
- 分圈结构
- 给定两个点(a,b)和(c,d)->这两个点可以画一个框```(a,b)和(c,d)分别为左上角和右下角```
  - 解决两个边界问题
    - 两个点在一行
    - 两个点在一列

- 画完最大的框再将左上角点沿对角线下移一个点,右下角的点沿对角线上移一个点。依次画完所有框就是答案。

```java
package cn.cqu.ccc1z.dayo4.zuo;

public class PrintMatrixSpiralOrder {

    public static void spiralOrderPrint(int[][] martrix){
        int tR = 0;
        int tC = 0;
        int dR = martrix.length - 1;
        int dC = martrix[0].length - 1;
        while(tR <= dR && tC <= dC){
            printEdge(martrix,tR++,tC++,dR--,dC--);
        }
    }

    /**
     * 给定两个点,以这两个点为左上角和右下角打印一个矩形
     * @param m 矩阵
     * @param tR 左上角的行
     * @param tC 左上角的列
     * @param dR 右下角的行
     * @param dC 右下角的列
     */
    public static void printEdge(int[][] m,int tR,int tC,int dR,int dC){
        //1.如果两个点在一行
        if(tR == dR){
            for(int i = tC ; i <= dC ;i++){
                System.out.println(m[tR][i] + " ");
            }
        }else if(tC == dC){
            //两个在一列
            for(int i = tR ;i <=dR;i++){
                System.out.println(m[i][tC]+" ");
            }
        }else{
            int curC = tC;
            int curR = tR;
            while(curC != dC){
                System.out.println(m[tR][curC] + " ");
                curC++;
            }
            while(curR != dR){
                System.out.println(m[curR][dC] + " ");
                curR++;
            }
            while(curC != tC){
                System.out.println(m[dR][curC] + " ");
                curC--;
            }
            while(curR != tR){
                System.out.println(m[curR][tC] + " ");
                curR--;
            }
        }
    }

    public static void main(String[] args) {
        int[][] matriax = {{1,2,3},{4,5,6},{7,8,9}};
        spiralOrderPrint(matriax);
    }
}
```

#### 旋转矩阵

- 给定一个正方形矩阵(n*n)，顺时针旋转90度打印。
  - 1 2 3     7 4 1
  - 4 5 6 -> 8 5 2
  - 7 8 9     9 6 3

- 给定左上角和右下角，跟上一道题一样。一圈一圈依次转完

```java
package cn.cqu.ccc1z.dayo4.zuo;

public class RotateMatrix {
    public static void rotateMatrix(int[][] matrix){
        int tR = 0;
        int tC = 0;
        int dR = matrix.length-1;
        int dC = matrix[0].length-1;
        while(tR < dR){
            rotateEdge(matrix,tR++,tC++,dR--,dC--);
        }
    }

    public static void rotateEdge(int[][] m,int tR,int tC,int dR,int dC){
        int times = dC - tC;
        int temp = 0;
        for(int i = 0 ; i != times ;i++){
            temp = m[tR][tC + i];
            m[tR][tC+i] = m[dR-i][tC];
            m[dR-i][tC] = m[dR][dC-i];
            m[dR][dC-i] = m[tR+i][dC];
            m[tR+i][dC] = temp;
        }
    }

    public static void printMatrix(int[][] matrix){
        for(int[] rows : matrix){
            for(int item : rows){
                System.out.print(item+ " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        System.out.println("旋转前:");
        printMatrix(matrix);
        rotateMatrix(matrix);
        System.out.println("=====================");
        System.out.println("旋转后:");
        printMatrix(matrix);
    }
}
```

#### 之字型打印矩阵

- 核心思想找对角线
- 设置两个点A,B一开始都指向起始点。
- A往右走,走到走不动了就往下走
- B往下走,走到走不动了就往右走
- 每次AB之间可以连城一条对角线
- 之字打印就是设置一个boolean值,控制每次打印时从B->A打印还是A->B打印
- **下面的代码顺序不能改变(对于AB两点,起始不变的位置先进行判断)**

```java
    while (tR != endR + 1) {
        printLevel(matrix, tR, tC, dR, dC, fromUp);
        tR = tC == endC ? tR + 1 : tR;
        tC = tC == endC ? tC : tC + 1;
        dC = dR == endR ? dC + 1 : dC;
        dR = dR == endR ? dR : dR + 1;
        fromUp = !fromUp;
    }
```
```java
package cn.cqu.ccc1z.dayo4.zuo;

public class ZigZagPrintMatrix {
    public static void printMatrixZigZag(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = 0;
        int dC = 0;
        int endR = matrix.length - 1;
        int endC = matrix[0].length - 1;
        boolean fromUp = false;
        while (tR != endR + 1) {
            printLevel(matrix, tR, tC, dR, dC, fromUp);
            tR = tC == endC ? tR + 1 : tR;
            tC = tC == endC ? tC : tC + 1;
            dC = dR == endR ? dC + 1 : dC;
            dR = dR == endR ? dR : dR + 1;
            fromUp = !fromUp;
        }
    }

    public static void printLevel(int[][] m, int tR, int tC, int dR, int dC, boolean f) {
        if (f) {
            while (tR != dR + 1) {
                System.out.println(m[tR++][tC--] + " ");
            }
        } else {
            while (dR != tR - 1) {
                System.out.println(m[dR--][dC++] + " ");
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };
        printMatrixZigZag(matrix);
    }
}
```

#### 在行和列都排好序的矩阵中找数

- 给定一个有N*m的整型矩阵matrix和一个整数k，matrix的每一行和每一列都是排好序的。实现一个函数，判断K是否在matrix中。
- 时间复杂度O(N+M)，额外空间复杂度为O(1).

- 思路一：从右上角的点开始找
  - 若右上角的点>K，则该列的数直接淘汰。此时该点向左移动一个点。
  - 若该点比K小，则此时该行的数直接淘汰。此时该点向下移动一个点。
  - 直到最后一个点。
- 思路二：从左下角的点开始找(思路同上)

```java
package cn.cqu.ccc1z.dayo4.zuo;

public class FindNumInSortedMatrix {
    public static boolean findNumInSortedMatrix(int[][] matrix,int k){
        int curR = 0;
        int curC = matrix[0].length - 1;
        boolean flag = false;
        while(curR < matrix.length  && curC > -1){
            if(matrix[curR][curC] > k){
                curC --;
            }else if(matrix[curR][curC] < k){
                curR++;
            }else{
                flag = true;
                break;
            }
        }
        return flag;
    }

    public static void main(String[] args) {
        int[][] matrix = {{1,3,5,6},{2,5,7,9},{4,6,8,10}};
        for(int[] rows : matrix){
            for(int item : rows){
                System.out.print(item + " ");
            }
            System.out.println();
        }
        boolean res = findNumInSortedMatrix(matrix, 4);
        System.out.println(res);
    }
}
```

#### 一个题的优化来源于其数据状况和问法的特殊性

#### 打印两个有序链表的公共部分

- 给定两个有序链表的头指针head1和head2，打印两个链表的公共部分
- 思路类似于外排

```java
package cn.cqu.ccc1z.dayo4.zuo;

/**
 * 打印两个有序链表的公共部分
 */
public class PrintCommonPart {
    public static class Node {
        public int value;
        public Node next;
        public Node(int data) {
            this.value = data;
        }
    }

    public static void printCommonPart(Node head1,Node head2){
        System.out.print("Common Part:");
        while(head1 != null && head2 != null){
            if(head1.value < head2.value){
                head1 = head1.next;
            }else if(head1.value > head2.value){
                head2 = head2.next;
            }else{
                System.out.print(head1.value + " ");
                head1 = head1.next;
                head2 = head2.next;
            }
        }
        System.out.println();
    }

    public static void printLinkedList(Node head){
        while(head != null){
            System.out.print(head.value+" ");
            head = head.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node node1 = new Node(2);
        node1.next = new Node(3);
        node1.next.next = new Node(5);
        node1.next.next.next = new Node(6);

        Node node2 = new Node(1);
        node2.next = new Node(2);
        node2.next.next = new Node(5);
        node2.next.next.next = new Node(7);
        node2.next.next.next.next = new Node(8);

        printLinkedList(node1);
        printLinkedList(node2);
        printCommonPart(node1, node2);

    }
}
```

### 链表的最优解常常取决于让额外空间复杂度低(笔试尽快通过,面试时尽量让额外空间复杂度低)

#### 判断一个链表是否为回文结构

- 给定一个链表的头节点head，请判断该链表是否为回文结构
- 进阶：如果链表长度为N，时间复杂度打到O(N)，额外空间复杂度达到O(1)
- 若使用额外空间，直接第一次遍历将链表放进栈中。(将链表逆序后再比较每一个数)
- 不使用额外空间
  - 快指针一次走两步
  - 慢指针一次走一步
  - 快指针走完时，慢指针来到链表中点位置（奇数个时刚好来到中点，偶数个来到中间的前一个位置）
    - 将右部分逆序
    - 再比较
    - 比较完之后恢复成原链表

```java
package cn.cqu.ccc1z.dayo4.zuo;

import java.util.Stack;

/**
 * 判断链表是否是回文链表
 *      1.不考虑额外空间复杂度:采用栈
 *      2.考虑额外空间复杂度：采用快慢指针
 */
public class IsPalindromeList {
    public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    // need n extra space
    public static boolean isPalindrome1(Node head) {
        Stack<Node> stack = new Stack<Node>();
        Node cur = head;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        while (head != null) {
            if (head.value != stack.pop().value) {
                return false;
            }
            head = head.next;
        }
        return true;
    }

    // need n/2 extra space
    public static boolean isPalindrome2(Node head) {
        if (head == null || head.next == null) {
            return true;
        }
        Node right = head.next;
        Node cur = head;
        while (cur.next != null && cur.next.next != null) {
            right = right.next;
            cur = cur.next.next;
        }
        Stack<Node> stack = new Stack<Node>();
        while (right != null) {
            stack.push(right);
            right = right.next;
        }
        while (!stack.isEmpty()) {
            if (head.value != stack.pop().value) {
                return false;
            }
            head = head.next;
        }
        return true;
    }

    // need O(1) extra space
    public static boolean isPalindrome3(Node head) {
        if (head == null || head.next == null) {
            return true;
        }
        Node n1 = head;
        Node n2 = head;
        while (n2.next != null && n2.next.next != null) { // find mid node
            n1 = n1.next; // n1 -> mid
            n2 = n2.next.next; // n2 -> end
        }
        n2 = n1.next; // n2 -> right part first node
        n1.next	 = null; // mid.next -> null
        Node n3 = null;
        while (n2 != null) { // right part convert
            n3 = n2.next; // n3 -> save next node
            n2.next = n1; // next of right node convert
            n1 = n2; // n1 move
            n2 = n3; // n2 move
        }
        n3 = n1; // n3 -> save last node
        n2 = head;// n2 -> left first node
        boolean res = true;
        while (n1 != null && n2 != null) { // check palindrome
            if (n1.value != n2.value) {
                res = false;
                break;
            }
            n1 = n1.next; // left to mid
            n2 = n2.next; // right to mid
        }
        n1 = n3.next;
        n3.next = null;
        while (n1 != null) { // recover list
            n2 = n1.next;
            n1.next = n3;
            n3 = n1;
            n1 = n2;
        }
        return res;
    }

    public static void printLinkedList(Node node) {
        System.out.print("Linked List: ");
        while (node != null) {
            System.out.print(node.value + " ");
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        Node head = null;
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(2);
        head.next.next.next = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(2);
        head.next.next.next.next = new Node(1);
        printLinkedList(head);
        System.out.print(isPalindrome1(head) + " | ");
        System.out.print(isPalindrome2(head) + " | ");
        System.out.println(isPalindrome3(head) + " | ");
        printLinkedList(head);
        System.out.println("=========================");

    }

}
```

#### 划分链表

- 将单向链表按某值划分成左边小、中间相等、右边大的形式
- 给定一个单向链表的头结点head，结点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是小于pivot的结点，中间部分都是值等于pivot的结点。右边部分都是值大于pivot的结点。
- 进阶：保留原相对次序。
- 思路1:将所有结点放入一个结点类型的数组，用荷兰国旗问题排好后再重新连接成链表。(做不到稳定性并且额外空间复杂度达不到O(1))。
- 思路二:稳定且O(1)：

  - Node less = null;
  - Node equal = null;
  - Node more = null;
- ```第一次遍历```:less = 第一个小于number的结点、equal=第一个等于number的结点、more = 第一个大于number的结点
  - 每个区域加入一个新的变量end第二次遍历时把每个区域填满(相当于三个链表)
  - 最后再将三个链表串起来即可
  - 边界扣在可能某个区域没有节点
- **这个head.next = null 如果不加 就会进入死循环**
- **如果要不改变原链表则需要复制原链表**

        while(head != null){
            next = head.next;
            head.next = null;
```java
package cn.cqu.ccc1z.day04.review;

public class SmallerEqualBigger {
    static class Node{
        private int value;
        private Node next;
        public Node(int value){
            this.value = value;
        }
    }

    public static Node partition(Node head,int pivot){
        if(head == null || head.next == null){
            return head;
        }
        Node sH = null;
        Node sT = null;
        Node eH = null;
        Node eT = null;
        Node bH = null;
        Node bT = null;
        Node next = null;

        while(head != null){
            next = head.next;
            head.next = null;
            if(head.value < pivot){
                if(sH == null){
                    sH = head;
                    sT = head;
                }else{
                    sT.next = head;
                    sT = sT.next;
                }
            }else if(head.value == pivot){
                if(eH == null){
                    eH = head;
                    eT = head;
                }else{
                    eT.next = head;
                    eT = eT.next;
                }
            }else{
                if(bH == null){
                    bH = head;
                    bT = head;
                }else{
                    bT.next = head;
                    bT = bT.next;
                }
            }
            head = next;
        }

        if(sT != null){
            sT.next = eH;
            eT = eT == null ? sT : eT;
        }
        if(eT != null){
            eT.next = bH;
        }
        return sH != null ? sH : eH != null ? eH : bH;
    }

    public static void printLinkedList(Node node) {
        System.out.print("Linked List: ");
        while (node != null) {
            System.out.print(node.value + " ");
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node head1 = new Node(7);
        head1.next = new Node(9);
        head1.next.next = new Node(1);
        head1.next.next.next = new Node(8);
        head1.next.next.next.next = new Node(5);
        head1.next.next.next.next.next = new Node(2);
        printLinkedList(head1);
        // head1 = listPartition1(head1, 4);
        Node res = partition(head1, 5);
//        System.out.println("============");
//        printLinkedList(head1);
        System.out.println("============");
        printLinkedList(res);

    }
}
```

#### 复制含有随机指针节点的链表

- 一种特殊的链表节点类描述如下:

- ```java
  public class Node{
      public int value;
      public Node next;
      public Node rand;
      public Node(int data){
          this.value = data;
      }
  }
  ```

- Node类中的value是节点值，next指针和正常单链表中next指针的意义一样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可以指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头结点。

- 进阶：不适用额外的数据结构，只用有限几个变量，且时间复杂度为O(N)

- 思路:

  - map(节点1,节点1')

  - ```java
    	while (cur != null) {
      		map.get(cur).next = map.get(cur.next);
      		map.get(cur).rand = map.get(cur.rand);
      		cur = cur.next;
      	}
    ```

- 进阶:(不用哈希表)
  - ①->②->③
  - 第一次遍历
    - ①->①'->②->②'->③->③'->null
  - 第二次遍历
    - 一次拿出两个节点
    - 找到第一个节点的random
    - random的next就是它的拷贝节点
    - 第一个节点的拷贝的random指向拷贝节点

```java
package cn.cqu.ccc1z.dayo4.zuo;

import java.util.HashMap;

public class CopyListWithRandom {
    static class Node{
        private int val;
        private Node random;
        private Node next;
        public Node(int value){
            this.val = value;
        }
    }

    /**
     * 方法一：使用哈希表
     * @param head
     * @return
     */
    public static Node copyListWithRandomI(Node head){
        HashMap<Node,Node> map = new HashMap<>();
        Node cur = head;
        while(cur != null){
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        while(cur != null){
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }

    /**
     * 方法二：不使用哈希表
     * @param head
     * @return
     */
    public static Node copyListWithRandomII(Node head){
        if(head == null){
            return null;
        }
        Node cur = head;
        Node next = null;
        //copy node and link to every node
        while(cur != null){
            next = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = next;
            cur = next;
        }
        cur = head;
        Node curCopy = null;
        //set copy node random
        while(cur != null){
            next = cur.next.next;
            curCopy = cur.next;
            curCopy.random = cur.random != null ? cur.random.next : null;
            cur = next;
        }
        Node res = head.next;
        cur = head;
        //split
        while(cur != null){
            next = cur.next.next;
            curCopy = cur.next;
            cur.next = next;
            curCopy.next = next != null ? next.next : null;
        }
        return res;
    }
}
```

#### 两个单链表相交的一系列问题(重点)

- 再本题中，单链表可能有环，也可能无环。给定两个单链表的头结点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个结点；如果不相交，返回null。要求：如果链表1的长度为N，链表2的长度为M，时间复杂度打到O(N+M)，额外空间复杂度打到O(1)。

  - 判断链表是否有环(单链表有环返回第一个环的结点，无环返回null)

    - 遍历的每一个结点都放在HashSet<>中，如果有环则HashSet中会出现重复结点
    - 不用HashSet，用快慢指针。
    - **当快慢指针相遇时。快指针回到head。此时快指针慢指针同时每次走一步。当他们再相遇时，相遇的结点就一定时入环结点。**

  - 判断两个无环单链表相交

    - 遍历链表1放到map里
    - 遍历链表二，每遍历一次就查map

    - 不用map
      - 遍历链表1得到链表1长度len1 结尾结点end1
      - 遍历链表2得到链表2长度len2 结尾结点end2
      - 先比较end1 == end2 再通过len1 len2拿到相交结点

  - 判断有环单链表相交(三种拓扑结构)

    - 各自成环，不相交
    - 先相交，再共享一个环
    - 3

  - 仅仅通过head1/head2/loop1/loop2来区分上面三种拓扑结构

    -  loop1 == loop2 第二种结构
      - 无环链表相交以空位置作为结尾，第二种结构改为以入环结点作为结尾
    - loop1 != loop2 第一或第三种结构
      - loop1不断通过next的方式往下走，如果loop1走回来了都还没发现loop2则两个链表不相交。如果相交则时结构三。此时返回loop1或者loop2都可以(两个结点都是相交结点)。

```java
package cn.cqu.ccc1z.day04.review;


import java.util.HashSet;

public class ListLoop {
    static class Node {
        private int value;
        private Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    /**
     * 方法一：使用hashset
     *
     * @param head
     * @return
     */
    public static Node getLoopNodeI(Node head) {
        if (head == null || head.next == null) {
            return null;
        }
        HashSet<Node> set = new HashSet<>();
        Node cur = head;
        Node next = null;
        while (cur.next != null) {
            next = cur.next;
            if (!set.contains(next)) {
                set.add(cur);
                cur = next;
            } else {
                return cur;
            }
        }
        return null;
    }

    /**
     * 方法2：不使用哈希表
     * 用快慢指针
     * 当快指针慢指针相遇时有环，此时将fast = head
     * 然后快指针慢指针同时走
     * 再相遇时的节点就是入环节点
     *
     * @param head
     * @return
     */
    public static Node getLoopNodeII(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node fast = head.next.next;
        Node slow = head.next;
        while (fast != slow) {
            if (fast.next == null || fast.next.next == null) {
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }

    /**
     * 使用哈希表
     *
     * @param head1
     * @param head2
     * @return
     */
    public static Node getIntersectionNodeI(Node head1, Node head2) {
        HashSet<Node> set = new HashSet<>();
        while (head1 != null) {
            set.add(head1);
            head1 = head1.next;
        }
        while (head2 != null) {
            if (set.contains(head2)) {
                return head2;
            } else {
                head2 = head2.next;
            }
        }
        return null;
    }

    /**
     * 不使用哈希表
     * 两个无环的：先遍历h1:得到长度和最后的节点end1,遍历h2:得到长度和最后的节点end2
     *
     * @param head1
     * @param head2
     * @return
     */
    public static Node getIntersectionNodeII(Node head1, Node head2) {
        Node loopA = getLoopNodeII(head1);
        Node loopB = getLoopNodeII(head2);
        if (loopA == null && loopB == null) {
            int lenA = 0;
            Node endA = head1;
            while (endA != null) {
                lenA++;
                endA = endA.next;
            }
            int lenB = 0;
            Node endB = head2;
            while (endB != null) {
                lenB++;
                endB = endB.next;
            }
            if (endA != endB) {
                return null;
            } else {
                int difference = Math.abs((lenA - lenB));
                for (int i = 0; i < difference; i++) {
                    head1 = lenA > lenB ? head1.next : head1;
                    head2 = lenA < lenB ? head2.next : head2;
                }
                while (head1 != head2) {
                    head1 = head1.next;
                    head2 = head2.next;
                }
                return head1;
            }
        }
        else if(loopA == null && loopB != null){
            return null;
        }else if(loopA != null && loopB == null){
            return null;
        }else{
            if(loopA == loopB){
                //将loopA或loopB作为A链表B链表的尾节点再重复无环链表相交问题
            }else{
                Node cur1 = loopA.next;
                while(cur1 != loopA){
                    if(cur1 == loopB){
                        return loopA;//返回loopB也可以，两个都是相交节点
                    }
                    cur1 = cur1.next;
                }
            }
        }
        return null;
    }

    public static void main(String[] args) {
        Node head = new Node(1);
        Node n1 = new Node(2);
        Node n2 = new Node(3);
        Node n3 = new Node(4);

        head.next = n1;
        n1.next = n2;
        n2.next = n3;
        n3.next = n1;

        Node res = getLoopNodeII(head);
        System.out.println(res.value);
    }
}
```

### 认识布隆过滤器(Bloom)和一致性哈希

- 用来查一个东西是否再某个集合里(常用在爬虫和黑名单系统里)

- 布隆过滤器就是一个集合的概念

- 一个黑名单里面有100亿个url(64字节)->放在哈希表中查询不现实

- 布隆过滤器就是能不能使用空间少一点但是存在一定几率的失误，失误是失误在把正确的当初错误的给过滤掉。在黑名单里的不会被误报。

- 布隆过滤器是一个大数组结构，数组中的每一个位置是一个bit
  - ```int[] arr = new int[100]``` ->一共能表示100*32 bit
  - 一个int是4 Byte = 32 bits
    - arr[0]:表示0~31
    - arr[1]:表示32~63
  
- **定位：**
  - 假如需要将6341描黑
  - 先6341/32拿到其所在的整数位置
  - 再计算6341%632计算其在哪个位置描黑(0->1)
  
- 一个url进来 准备K个哈希函数(h1,h2,...hk)

- 设数组为0-m

- 一个url进来先经过hi得到vi->vi%m得到 一个0-(m-1)的值
  
  - 得到k个[0~m-1]上的值，把这些值描黑
  
- 错误率体现在这个布隆过滤器开的太小

- **关键问题是布隆过滤器开多大**

- 布隆过滤器开多大和单样本大小没关系，和样本数量有关系

- **样本量(n)和失误率(P)是唯二确定布隆过滤器大小的参数**

- $$
  m = -  \frac{n*\ln p}{(\ln2)^2}
  $$

- $$
  k = \ln2 * \frac{m}{n} = 0.7 * \frac{m}{n}
  $$

  

- $$
  P_真=(1 - e^{-\frac{n*k}{m}})^k
  $$

  

- 由于m和k都是向上取整，那么真实的失误率一定是小于预定的失误率

- 为啥要用k个哈希函数而不是1个？因为需要保证失误率

- **1.容量要求较为苛刻 2.单样本容量较大 3.黑名单问题 4.是否允许有失误率**
  
  - **直接上布隆过滤器**
  
- **扩展：Hadoop框架**

# Day05

## 一致性哈希(目前很多分布式技术都采用，Google大数据论文)

- 经典的负载均衡是采用哈希函数得到value % (后端服务器个数)得到应该在哪个后端服务器上调用。
  - 在后端服务器数量固定时该方法没问题，但如果新增一台(改变服务器数量)后会出现数据迁移，问题很大。
- **一致性哈希:(哈希域是一个环，经典算法哈希域是多个桶)**
  - 前端相较于前面的经典方法没有差别
  - **服务器端：不同的服务器采用不同的id地址通过哈希函数得到多个不同的哈希值，将它们打到这个环上。请求通过前端和哈希函数得到的哈希值。在这个环上顺时针寻找，顺时针第一个碰到的服务器就是所寻找的后端服务器**
- **怎么顺时针寻找：计算出的服务器的哈希值，排序后放在代理服务器的数组中。请求进来后再通过二分查找找该数组中比需求的哈希值大的那台服务器，如果超出了数组的限定，就是找第一台服务器。(环形结构)**

- **增加和删除服务器的数据迁移：找比要添加(删除)的服务器的下一个服务器要(给)数据**。
- **问题：**
  - 初始机器数量很少的时候无法保证整个环被均分(哈希函数是离散函数，无法保证负载均衡)。
  - 在增加和删除服务器的时候也会破坏均衡性。
- **解决方案：**
  - 虚拟节点技术：对每一台实际的服务器建立一张路由表（如：m1对应1万个虚拟节点v1_1,v1_2...v1_10000），用虚拟节点去抢环。在数量大的情况下根据哈希函数的数学特点，能实现负载均衡。
    - 比如m1的hostname:196.125.1.1
    - 195.125.1.1-1进一个哈希函数得到一个哈希值
    - 195.125.1.1-2进一个哈希函数得到一个哈希值
    - 这样即可建立一个多虚拟节点的路由表
  - **服务器进环或者出环是向(给)环中已有的N个服务器要(给)数据。变成N+1(N-1)个服务器评分。**

### 随时找到数据流中的中位数

- 有一个源源不断地吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MeidanHolder可以随时取得之前吐出所有数的中位数。
  - 如果MedianHolder已经保存了吐出的N个数，那么任意时刻将一个新数加入到MedianHolder的过程，其时间复杂度是O(longN)。
  - 取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)。

- 优先级队列(PriorityQueue<Integer> heap = new PriorityQueue<>())：默认是小根堆

- 自己定义比较器定义大根堆：

```java
PriorityQueue<Integer> heap = new PriorityQueue<>((o1,o2)->o2-o1);
```

- 思路：准备两个堆，一个大根堆一个小根堆
- new_number <= 大根堆堆顶 放到大根堆
- 大根堆和小根堆的size不能超过1，超过1就大根堆(小根堆)堆顶弹出一个数加入小根堆(大根堆)。

```java
package cn.cqu.ccc1z.review;

import java.util.PriorityQueue;

public class MedianFinder {
    /** initialize your data structure here. */
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;
    public MedianFinder() {
        maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);
        minHeap = new PriorityQueue<>();
    }

    public void modifyTwoheapSize(){
        if(this.maxHeap.size() == this.minHeap.size()+2){
            //如果大根堆中的个数大于小根堆的个数加1
            this.minHeap.add(this.maxHeap.poll());
        }
        if(this.minHeap.size() == this.maxHeap.size()+2){
            //如果小根堆比大根堆多2
            this.maxHeap.add(this.minHeap.poll());
        }
    }
    public void addNumber(int num) {
        if(this.maxHeap.isEmpty()){
            //如果大根堆为空，第一个数直接入大根堆
            this.maxHeap.add(num);
            return;
        }
        if(this.maxHeap.peek() >= num){
            //如果大根堆堆顶元素比num大
            this.maxHeap.add(num);
        }else{
            if(this.minHeap.isEmpty()){
                //如果num比大根堆堆顶元素大且小根堆为空
                this.minHeap.add(num);
                return;
            }
            if(this.minHeap.peek() > num){
                //如果小根堆堆顶元素比大
                this.maxHeap.add(num);
            }else{
                this.minHeap.add(num);
            }
        }
        modifyTwoheapSize();
    }

    public double getMedian() {
        int minSize = this.minHeap.size();
        int maxSize = this.maxHeap.size();
        if(minSize + maxSize == 0){
            throw new RuntimeException("no number");
        }
        Integer minHead = this.minHeap.peek();
        Integer maxHead = this.maxHeap.peek();
        if(((minSize + maxSize) & 1) == 0){
            return (maxHead+minHead) / 2;
        }
        return maxSize > minSize ? maxHead : minHead;
    }
}
```

```java
    Integer minHead = this.minHeap.peek();
    Integer maxHead = this.maxHeap.peek();
```
- 注意上面是Integer，写成int会报空指针异常

## 题目二(哈夫曼编码)

- 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板？



- 例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10，20，30三个部分。
  - 如果先把长度60的金条分成10和50，花费60。
  - 再把长度50的金条分成20和30，花费50。
  - 一共花费110铜板。
  - 但是如果。
  - 先把长度60的金条分成30和30，花费60
  - 再把长度30金条分成10和20，划分30
  - 一共花费90铜板
- 输入一个数组，返回分割的最小代价。

- 思路：贪心算法，用小根堆实现
  - 从小根堆里每次拿出两个组成一个数再放回去直到小根堆最后只剩一个数。

```java
package cn.cqu.ccc1z.zuo;

import java.util.PriorityQueue;

/**
 * - 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板？
 *
 *
 *
 * - 例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10，20，30三个部分。
 *   - 如果先把长度60的金条分成10和50，花费60。
 *   - 再把长度50的金条分成20和30，花费50。
 *   - 一共花费110铜板。
 *   - 但是如果。
 *   - 先把长度60的金条分成30和30，花费60
 *   - 再把长度30金条分成10和20，划分30
 *   - 一共花费90铜板
 * - 输入一个数组，返回分割的最小代价。
 *
 * - 思路：贪心算法，用小根堆实现
 *   - 从小根堆里每次拿出两个组成一个数再放回去直到小根堆最后只剩一个数。
 */
public class LessMoney {
    public static int leseeMoney(int[] arr){
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int i = 0; i < arr.length; i++) {
            minHeap.add(arr[i]);
        }
        int sum = 0;
        int cur = 0;
        while(minHeap.size() > 1){
            cur = minHeap.poll()+minHeap.poll();
            sum += cur;
            minHeap.add(cur);
        }
        return sum;
    }

    public static void main(String[] args){
        //solution
        int[] arr = {6,7,8,9};
        System.out.println("least money= "+leseeMoney(arr));
        
    }
}
```

## 题目三

- 输入:
  - 参数1：正数数组costs
  - 参数2：正数数组profits
  - 参数3：正数k
  - 参数4：正数m
- cost[i]表示i号项目的花费
- profits[i]表示i号项目再扣在花费之后还能挣到的钱(利润)
- k表示你不能并行，只能串行的最多做k个项目
- m表示你的初始资金



- 说明：你每做完一个项目，马上获得的利益，可以支持你去做下一个项目。
- 输出：你最后获得的最大钱数。

- 思路：堆实现贪心算法 
  - 所有项目先按花费cost实现一个小根堆
  - 所有项目按盈利profits实现一个大根堆(一开始是空的)
  - 小根堆里小于等于起始资金的弹出进入大根堆，弹到小根堆堆顶大于起始资金停止。
  - 找大根堆堆顶的项目做，初始资金增加
  - 循环k次
- 以下两种方法均可

```java
package cn.cqu.ccc1z.zuo;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * - 输入:
 * - 参数1：正数数组costs
 * - 参数2：正数数组profits
 * - 参数3：正数k
 * - 参数4：正数m
 * - cost[i]表示i号项目的花费
 * - profits[i]表示i号项目再扣在花费之后还能挣到的钱(利润)
 * - k表示你不能并行，只能串行的最多做k个项目
 * - m表示你的初始资金
 * <p>
 * <p>
 * <p>
 * - 说明：你每做完一个项目，马上获得的利益，可以支持你去做下一个项目。
 * - 输出：你最后获得的最大钱数。
 * <p>
 * - 思路：堆实现贪心算法
 * - 所有项目先按花费cost实现一个小根堆
 * - 所有项目按盈利profits实现一个大根堆(一开始是空的)
 * - 小根堆里小于等于起始资金的弹出进入大根堆，弹到小根堆堆顶大于起始资金停止。
 * - 找大根堆堆顶的项目做，初始资金增加
 * - 循环k次
 */

public class IPO {
    public static class Node{
        public int c;
        public int p;
        public Node(int c,int p){
            this.c = c;
            this.p = p;
        }
    }

    public static class MaxProfitComparator implements Comparator<Node>{
        @Override
        public int compare(Node o1,Node o2){
            return o2.p-o1.p;
        }
    }

    public static  class MinCoostComparator implements Comparator<Node>{
        @Override
        public int compare(Node o1,Node o2){
            return o1.p - o2.p;
        }
    }
    /**
     * @param costs   cost[i]表示i号项目的花费
     * @param profits profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)
     * @param k       表示你不能并行，只能串行的最多做k个项目
     * @param m       表示你的初始资金
     * @return 最后获得的最大钱数
     */
    public static int findMaximizedCapoital(int[] costs, int[] profits, int k, int m) {
//        //用小根堆存放cost
//        PriorityQueue<Integer> costsHeap = new PriorityQueue<>();
//        //用大根堆存放profits
//        PriorityQueue<Integer> profitsHeap = new PriorityQueue<>((o1, o2) -> o2 - 1);
//        for (int i = 0; i < costs.length; i++) {
//            costsHeap.add(costs[i]);
//        }
//        for (int i = 0; i < k; i++) {
//            while (!costsHeap.isEmpty()&& m >=costsHeap.peek()) {
//                Integer curcost = costsHeap.poll();
//                int index = 0;
//                while (curcost != costs[index]) {
//                    index++;
//                }
//                profitsHeap.add(profits[index]);
//            }
//            if(profitsHeap.isEmpty()){
//                return m;
//            }
//
//            m += profitsHeap.poll();
//        }
//
//        return m;
        Node[] nodes = new Node[profits.length];
        for (int i = 0; i < profits.length; i++) {
            nodes[i] = new Node(costs[i],profits[i]);
        }

        PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCoostComparator());
        PriorityQueue<Node> maxProfQ = new PriorityQueue<>(new MaxProfitComparator());

        for(int i = 0 ; i < nodes.length ; i++){
            minCostQ.add(nodes[i]);
        }

        for(int i = 0 ; i < k ; i++){
            while(!minCostQ.isEmpty() && minCostQ.peek().c <= m){
                maxProfQ.add(minCostQ.poll());
            }
            if(maxProfQ.isEmpty()){
                return m;
            }
            m += maxProfQ.poll().p;
        }
        return m;
    }

    public static void main(String[] args) {
        int[] costs = {1,2,3,4,5};
        int[] profits = {2,3,4,5,6};
        int m = 2;
        int k = 5;
        System.out.println(findMaximizedCapoital(costs,profits,k,m));
    }
}
```

## 二叉树先序、中序、后序遍历的非递归实现

- 先序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中
- 递归版本
- 非递归版本：
  - 先序遍历(用栈结构实现)
  - 中序遍历(用栈结构实现)
    - 第一次压一棵树的所有左边界
  - 后序遍历(用两个栈实现)
    - 把先序遍历中左右->中右左
    - 在打印的时候不打印二十放到栈里去
    - 出栈的顺序就是左右中

```java
package cn.cqu.ccc1z.zuo;

import java.util.Stack;

public class PreInPosTraversal {
    public static class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value){
            this.value = value;
        }
    }

    /**
     * 先序遍历(递归版)
     * @param head
     */
    public static void preOrderRecur(Node head){
        if(head == null) return;
        System.out.println(head.value+" ");
        preOrderRecur(head.left);
        preOrderRecur(head.right);
    }

    public static void preOrderUnRecur(Node head){
        System.out.println("pre-order: ");
        if(head != null){
            Stack<Node> stack = new Stack<Node>();
            stack.add(head);
            while(!stack.isEmpty()){
                head = stack.pop();
                System.out.println(head.value+" ");
                if(head.right != null){
                    stack.push(head.right);
                }
                if(head.left != null){
                    stack.push(head.left);
                }
            }
        }
        System.out.println();
    }

    /**
     * 中序遍历(递归版)
     * @param head
     */
    public static void inOrderRecur(Node head){
        if(head == null) return;
        inOrderRecur(head.left);
        System.out.println(head.value + " ");
        inOrderRecur(head.right);
    }

    public static void inOrderUnRecur(Node head){
        System.out.println("in-order");
        if(head != null){
            Stack<Node> stack = new Stack<>();
            while(!stack.isEmpty() || head != null){
                if(head != null){
                    stack.push(head);
                    head = head.left;
                }else{
                    head = stack.pop();
                    System.out.println(head.value + " ");
                    head = head.right;
                }
            }
        }
        System.out.println();
    }

    /**
     * 后序遍历(递归版)
     * @param head
     */
    public static void posOrderRecur(Node head){
        if(head == null) return;
        posOrderRecur(head.left);
        posOrderRecur(head.right);
        System.out.println(head.value+" ");
    }

    public static void posOrderUnRecur(Node head){
        System.out.println("pos-order: ");
        if(head != null){
            Stack<Node> s1 = new Stack<>();
            Stack<Node> s2 = new Stack<>();
            s1.push(head);
            while(!s1.isEmpty()){
                head = s1.pop();
                s2.push(head);
                if(head.left != null){
                    s1.push(head.left);
                }
                if(head.right != null){
                    s1.push(head.right);
                }
            }
            while(!s2.isEmpty()){
                System.out.println(s2.pop().value+" ");
            }
        }
        System.out.println();
    }
}
```

### 折纸问题

- 把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的。...,请从上到下打印所有的折痕方向。
- N=1 打印 down
- N=2 打印 down down up
- 思路：每一次对折都会在上一次对折产生的折痕两侧产生两个新的折痕
  - **将这些折痕构成一颗二叉树(头节点为down节点，每颗左子树的头节点为down节点，每颗右子树的头节点为up节点)**
  - 中序遍历打印即是结果

- **一些思路**：
  - **一共折n次，产生2的n次方-1条折痕**
  - **一颗满二叉树有2的n次方-1个节点**
  - **折的过程刚好是一个构建二叉树的过程**

```java
package cn.cqu.ccc1z.zuo;

public class PaperFolding {
    public static void printAllFolds(int N){
        printProcess(1,N,true);
    }

    /**
     * 
     * @param i 当前层数
     * @param N 折叠多少次
     * @param down  是否是向下
     */
    public static void printProcess(int i,int N,boolean down){
        if(i > N) return;
        printProcess(i+1,N,true);
        System.out.println(down ? "down" : "up");
        printProcess(i+1,N,false);
    }

    public static void main(String[] args){
        int N = 4;
        printAllFolds(N);
    }
}
```

### 较为直观的打印二叉树

### 在二叉树中找到一个节点的后继节点

- 现有一种新的二叉树结点类型如下：

```java
public class Node{
    public int value;
    public Node left;
    public Node right;
    public Node parent;
    
    public Node(int data){
        this.value = datal
    }
}
```

- 该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一颗Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。只给一个二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。

- 思路：
  
  - 如果x节点有右子树，那么它右子树的最左边节点就是x节点的后继节点
  
  - 如果x节点没有右子树，那么就找它是哪一个节点左子树上的最后一个节点
  
  - ```java
           Node parent = head.parent;
            while(parent != null && parent.left != head){
                head = parent;
                parent = head.parent;
            }
            return parent;
    ```

```java
package cn.cqu.ccc1z.zuo;

public class DescendantNode {
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        public Node parent;

        public Node(int value){
            this.value = value;
        }
    }

    public static Node getNextNode(Node head){
        if(head == null){
            return head;
        }
        if(head.right != null){
            return getLeftMost(head.right);
        }else{
            Node parent = head.parent;
            while(parent != null && parent.left != head){
                head = parent;
                parent = head.parent;
            }
            return parent;
        }
    }

    public static Node getLeftMost(Node head){
        if(head == null){
            return head;
        }
        while(head.left != null){
            head = head.left;
        }
        return head;
    }
}
```

![有右子树](C:\Users\44766\Desktop\有右子树.png)

![无右子树](C:\Users\44766\Desktop\无右子树.png)

### 在数组中找到一个局部最小的位置(并不是非得有序才能二分)

- 定义局部最小的概念。arr长度为1时，arr[0]时局部最小。arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]时局部最小；如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有arr[i] < arr[i-1]，又有arr[i]<arr[i+1]，那么arr[i]是局部最小。(两头位置只需要比一个数小即是局部位置，中间的数必须比前后的数都小才是局部位置)
- 给定无序数组arr，已知arr中任意两个相邻的数都不相等。写一个函数，只需返回arr中任意一个局部最小出现的位置即可。

- 思路：二分
  - 先看0位置的数和N-1位置是不是局部最小
  - 如果0位置和N-1位置都不是局部最小
    - 0-1位置是一个向下的趋势，(N-1)->(N-2)位置也是一个向下的趋势,那么中间一定有局部最小。
    - 判断mid位置是不是局部最小
    - 如果mid位置不是局部最小
      - 若arr[m-1] < arr[m]，那么arr[m]到arr[m-1]是向下趋势， 则1->(m-1)一定会有局部最小，再二分。

```java
package cn.cqu.ccc1z.review;

import java.util.Arrays;

public class FindOneLessValueIndex {
    public static int getLessIndex(int[] arr){
        if(arr == null || arr.length == 0){
            return -1;
        }
        if(arr[0] < arr[1]){
            return 0;
        }
        if(arr[arr.length-1] < arr[arr.length-2]){
            return arr.length-1;
        }
        int left = 1;
        int right = arr.length-2;
        int mid = 0;
        while(left < right){
            mid = (left+right) / 2;
            if(arr[mid] > arr[mid-1]){
                right = mid-1;
            }
            else if(arr[mid] > arr[mid+1]){
                left = mid+1;
            }else{
                return mid;
            }
        }
        return left;
    }

    public static void main(String[] args) {
        int[] arr = { 6, 5, 3, 4, 6, 7, 8 };
        System.out.println(Arrays.toString(arr));
        int index = getLessIndex(arr);
        System.out.println("index: " + index + ", value: " + arr[index]);

    }
}
```

# Day06

## 并查集(一种高级数据结构)

- 逻辑结构是数学概念上的一些集合(不是java中的set)
- 提供两个功能
  - isSameSize(A,B)：查A,B两个元素是否属于一个集合
  - union(A,B)：把A元素所在的集合和B元素所在的集合合并成一个大集合

- 可以用list、HashSet来设计这个集合结构，但是开销较大(遍历的开销较大)
- 落地结构
  - **一个元素value有一个指向上级的p指针。**(类似于单向链表?)
- 假设一上来有五个元素，这五个元素各自成一个集合
  - 每一个元素的上级指针指回自己
- union集合1和集合2
  - 假设一个集合的大小就是集合中的节点个数--集合1和集合2的大小都是1
    - 那么集合1和集合2谁挂在谁的底下无所谓
    - **挂在头上的(p指针指向自己)的那个节点就叫做这个集合的代表点**(合并完之后1所在集合的代表点就是2)
    - **再与3集合合并--较少的节点的集合挂在较大的集合的下面(查元素1和元素3查出来代表点都是2，所以他们是在同一个集合中)**
- **最重要的优化：查询时，在通向代表节点的道路上，在返回代表节点之前，让路上的每个节点都指向代表节点**。(这个操作之后再次查询就会很节约时间)

```java
public Data findDaibiao(Data node) {
    Data father = fatherMap.get(node);
    if (father != node) {
        father = findDaibiao(father);
    }
    //把所有节点的父都改成代表节点--抹平的过程
    fatherMap.put(node, father);
    return father;
}
```

- **用HashMap的键值对对应关系来实现往上指的过程的**
  - fatherMap：(key,value)->key的父亲节点表示value
  - sizeMap：
    - (key,value)->如果Data是这个集合的代表节点，value就是这个集合的大小
    - 如果Data不是这个集合的代表节点，那么这条记录就是无效的

```java
public HashMap<Data,Data> fatherMap;
public HashMap<Data,Integer> sizeMap;
```

```java
package cn.cqu.ccc1z.zuo;

import java.util.HashMap;
import java.util.List;

/**
 * 并查集
 */
public class UnionFind {
    public static class Data {
        //whatever you like
    }

    public static class UnionFindSet {
        /**
         * fatherMap:(key,value)->value是key的上级节点
         * sizeMap(key,value)->只有当key是集合的代表节点时，value才是集合的size
         * 其他情况废弃这个map
         */
        public HashMap<Data, Data> fatherMap;
        public HashMap<Data, Integer> sizeMap;

        public UnionFindSet(List<Data> nodes) {
            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();
            makeSets(nodes);
        }

        /**
         * 使用并查集的前提是每一个元素一开始各自成一个集合
         *
         * @param nodes 一上来必须得告诉我所有的元素
         */
        private void makeSets(List<Data> nodes) {
            fatherMap.clear();
            sizeMap.clear();
            for (Data node : nodes) {
                fatherMap.put(node, node);
                sizeMap.put(node, 1);
            }
        }

        public Data findDaibiao(Data node) {
            Data father = fatherMap.get(node);
            if (father != node) {
                father = findDaibiao(father);
            }
            //把所有节点的父都改成代表节点--抹平的过程
            fatherMap.put(node, father);
            return father;
        }

        public boolean isSameSet(Data a, Data b) {
            return findDaibiao(a) == findDaibiao(b);
        }

        public void union(Data a, Data b) {
            if (a == null || b == null) {
                return;
            }
            Data aHead = findDaibiao(a);
            Data bHead = findDaibiao(b);
            if (aHead != bHead) {
                int aSetSize = sizeMap.get(aHead);
                int bSetSize = sizeMap.get(bHead);
                if (aSetSize <= bSetSize) {
                    fatherMap.put(aHead, bHead);
                    sizeMap.put(bHead, aSetSize + bSetSize);
                } else {
                    fatherMap.put(bHead, aHead);
                    sizeMap.put(aHead, aSetSize + bSetSize);
                }
            }
        }
    }
}
```

- **并查集的时间复杂度**
  - 假设O(N)级别的元素个数
  - 查询操作(findDaibiao())次数+合并操作次数(union())逼近了O(N)或以上
  - 那么单次查询和单词合并的平均复杂度O(1)

##  前缀树

### 什么是前缀树

- trie tree(prefix tree)
- 假设有三个字符串分别为```abc```,```bcd```,```abd```,可以将任意字符串加入前缀树
- 一开始这棵树是一个空节点，从头节点开始判断有没有到被加入字符串的路
- 给每个节点封装两个数据项
  - end：有多少个字符串以当前节点结尾
    - 比如先加abc->c后面的那个节点end=1,前面两个end=0
    - 再加ab,b后面的那个节点end=1
    - 再加abc->c后面的end=2
    - 查找字符串abc出现了几次->直接找头节点有没有到a,a有没有到b,b有没有到c。c的end数量就是出现了多少次。

```java
package cn.cqu.ccc1z.zuo;

/**
 * 前缀树
 */
public class TrieTree {
    public static class TrieNode{
        public int path;//有多少个节点经过我
        public int end;//是多少个字符串的结尾
        public TrieNode[] map;//有多少条边
        //public HashMap<Integer,TrieNode> map;//key是ASCII码,value是下一个节点

        public TrieNode(){
            path = 0;
            end = 0;
            map = new TrieNode[26];
            //map[0]表示走向a的路,map[25]表示走向z的路 如果为空，则不存在走向对应字母的路
        }
    }

    public static class Trie{
        private TrieNode root;

        public Trie(){
            root = new TrieNode();
        }

        /**
         * 假设加入的字符是"abc"
         * root为空
         * "abc"->['a','b','c']
         * node指向root,index
         * 遍历该字符串
         *  1.index = 'a' - 'a' = 0
         *  node.map[index]==null->node没有到'a'的路
         *  建出这条路
         *  node往下走
         * @param word
         */
        public void insert(String word){
            if(word == null){
                return;
            }
            char[] chs = word.toCharArray();
            TrieNode node = root;
            int index = 0;
            //一路沿途建立节点
            for(int i = 0; i < chs.length;i++){
                //当前字符的ASCII码-'a'结果是找路有没有
                index = chs[i] - 'a';
                if(node.map[index] == null){
                    node.map[index] = new TrieNode();
                }
                node = node.map[index];
                node.path++;
            }
            node.end++;
        }

        public void delete(String word){
            if(search(word) != 0){
                char[] chs = word.toCharArray();
                TrieNode node = root;
                int index = 0;
                for (int i = 0; i < chs.length; i++) {
                    index = chs[i] - 'a';
                    if(node.map[index].path-- == 1){
                        node.map[index] = null;
                        return;
                    }
                    node = node.map[index];
                }
                node.end--;
            }
        }

        public int search(String word){
            if(word == null){
                return 0;
            }
            char[] chs = word.toCharArray();
            TrieNode node = root;
            int index = 0;
            for(int i = 0 ;i<chs.length;i++){
                index = chs[i] - 'a';
                if(node.map[index] == null){
                    return 0;
                }
                node = node.map[index];
            }
            return node.end;
        }

        /**
         * 查找有多少个字符以"pre"开头
         * @param pre
         * @return
         */
        public int prefixNumber(String pre){
            if(pre == null){
                return 0;
            }
            char[] chs = pre.toCharArray();
            TrieNode node = root;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = chs[i] - 'a';
                if(node.map[index] == null){
                    return 0;
                }
                node = node.map[index];
            }
            return node.path;
        }
    }
}

```

- **找一个字符串中有多少个字符是以"hel"开头的-单词长度是多少时间复杂度就是多少**
  - 找l的path有多少就有多少是以hel开头的

- **如果发现有一个功能适合前缀树，那么可以直接再前缀树中加一个功能项。**

### 题目1

- 一个字符串类型的数组arr1，另一个字符串类型的数组arr2.
  - arr2中有哪些字符，是arr1中出现的？请打印

### 题目2

- 一个字符串类型的数组arr1，另一个字符串类型的数组arr2.
  - arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印

## 图

- 不论是有向图还是无向图，都可以用有向图来表达。

### 邻接表

![邻接表](C:\Users\44766\Desktop\邻接表.PNG)

### 邻接矩阵

![邻接矩阵](C:\Users\44766\Desktop\邻接矩阵.PNG)

- Node

```java
package cn.cqu.ccc1z.zuo;

import java.util.ArrayList;

/**
 * 图里的node
 */
public class Node {
    public int value;
    public int in;		//入度：有多少个节点指向我
    public int out;		//出度：有多少个节点出去
    public ArrayList<Node> nexts;	//从我出发能到达的下一个节点(邻居节点)
    public ArrayList<Edge> edges;	//从我出发(我是from)发散出边的集合

    public Node(int value){
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<Edge>();
    }
}
```

- Edge

```java
package cn.cqu.ccc1z.zuo;

public class Edge {
    public int weight;
    public Node from;
    public Node to;

    public Edge(int weight,Node from,Node to){
        this.weight = weight;
        this.from =from;
        this.to = to;
    }
}
```

- Graph

```java
package cn.cqu.ccc1z.zuo;

import java.util.HashMap;
import java.util.HashSet;

/**
 * 图在内存中的样子
 * 所有的点和边的集合
 */
public class Graph {

    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    public Graph(){
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

- 生成图

```java
package cn.cqu.ccc1z.zuo;

public class GraphGenerator {
    public static Graph createGraph(Integer[][] matrix){
        Graph graph = new Graph();
        for (int i = 0; i < matrix.length; i++) {
            Integer from = matrix[i][0];
            Integer to = matrix[i][1];
            Integer weight = matrix[i][2];

            if(!graph.nodes.containsKey(from)){
                graph.nodes.put(from,new Node(from));
            }

            if(!graph.nodes.containsKey(to)){
                graph.nodes.put(to,new Node(to));
            }

            Node fromNode = graph.nodes.get(from);
            Node toNode = graph.nodes.get(to);
            Edge newEdge = new Edge(weight,fromNode,toNode);
            fromNode.nexts.add(toNode);
            fromNode.out++;
            toNode.in++;
            fromNode.edges.add(newEdge);
            graph.edges.add(newEdge);
        }
        return graph;
    }
}
```

### 宽度优先遍历(BFS)

- 概念：离源节点近的节点先输出，远的节点后输出

- 利用队列实现
- 从源节点开始依次按照宽度进队列，然后弹出
- 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
- 直到队列变空

### 深度优先遍历(DFS)

- 概念：每一个节点的每一条路走到最深再返回父
- 利用栈实现
- 从源节点开始把节点按照深度放入栈，然后弹出
- 每弹出一个点，把该节点下一个没有进过栈的邻节点放入栈
- 直到栈变空

## 图的常见算法

### 拓扑排序算法(未看)

- 适用范围：要求有向图，且有入度为0的节点，且没有环
- 每个项目都有一些依赖(依赖之间还有依赖)，要以怎样的顺序来编译这些依赖才能成功编译出A(决定先做哪个再做哪个)

### kruskal算法(最小生成树算法)(未看)

- 适用范围：要求无向图

### prim算法(最小生成树算法)(未看)

- 适用范围：要求无向图

### Dijkstra算法(未看)

- 适用范围：没有权值为负数的边

# Day07

## 暴力递归

- 把问题化为规模缩小了的同类问题的子问题
- 有明确的不需要继续进行递归的条件(base case)
- 有当得到了子问题的结果之后的决策过程
- 不记录每一个子问题的解

## 动态规划

- 从暴力递归中来
- 将每一个子问题的解记录下来，避免重复计算
- 把暴力递归的过程，抽象成了状态表达
- 并且存在化简状态表达，使其更加简洁的可能

### 题目1

- 求n的阶乘

```java
package cn.cqu.ccc1z.day07.zuo;

/**
 * 求n!
 */
public class Factorial {
    public static long getFactorialRecur(int num){
        if(num == 1){
            return 1;
        }
        return (long) num * getFactorialRecur(num-1);
    }

    public static long getFactorialDp(int num){
        long result = 1;
        for(int i = 1 ; i <= num ;i++){
            result *= i;
        }
        return result;
    }
}
```

### 题目2(最小路径和)[理解暴力递归的缺陷以及动态规划的优点]

- 给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和。

#### 暴力递归

- base case：当前点到达右下角，返回右下角那个点的代价
- **暴力递归不保存走过的路径(子状态的解)会导致大量的重复运算**
- **时间复杂度：L个点只要没到最后一行或者最后一列，两条路都要走->2的L次方**

```java
/**
 * 从[i,j]到右下角的最小路径和
 * @param matrix
 * @param i
 * @param j
 * @return
 */
public static int process(int[][] matrix,int i,int j){
    //base case
    if(i == matrix.length-1 && j == matrix[0].length-1){
        return matrix[i][j];
    }
    if(i == matrix.length-1){
        //来到最后一行只能往右走
        return matrix[i][j] + process(matrix,i,j+1);
    }
    if(j == matrix[0].length-1){
        //来到最右边一列只能向下走
        return matrix[i][j] + process(matrix,i+1,j);
    }
    return matrix[i][j] + Math.min(process(matrix,i,j+1),process(matrix,i+1,j));
}
```

#### 优化暴力递归：

- 计划搜索：做一个傻缓存(计算过的过程放到一个map里)。
- 时间复杂度：每个点都只算一遍 --- O(N)

```java
//傻缓存
static HashMap<String, Integer> cache = new HashMap<>();

/**
 * 计划搜索，加入一个傻缓存
 *
 * @param matrix
 * @param i
 * @param j
 * @return
 */
public static int process1(int[][] matrix, int i, int j) {
    int result = 0;
    //base case
    if (i == matrix.length - 1 && j == matrix[0].length - 1) {
        result = matrix[i][j];
    } else if (i == matrix.length - 1) {
        //来到最后一行只能往右走
        int next = 0;
        String nextKey = String.valueOf(i) + "_" + String.valueOf(j + 1);
        if (cache.containsKey(nextKey)) {
            next = cache.get(nextKey);
        } else {
            next = process1(matrix, i, j + 1);
        }
        result = matrix[i][j] + next;
    } else if (j == matrix[0].length - 1) {
        int next = 0;
        String nextKey = String.valueOf(i + 1) + "_" + String.valueOf(j);
        if (cache.containsKey(nextKey)) {
            next = cache.get(nextKey);
        } else {
            next = process1(matrix, i + 1, j);
        }
        result = matrix[i][j] + next;
    } else {
        int downNext = 0;
        String downNextKey = String.valueOf(i + 1) + "_" + String.valueOf(j);
        if (cache.containsKey(downNextKey)) {
            downNext = cache.get(downNextKey);
        } else {
            downNext = process1(matrix, i + 1, j);
        }
        int rightNext = 0;
        String rightNextKey = String.valueOf(i) + "_" + String.valueOf(j + 1);
        if (cache.containsKey(rightNextKey)) {
            rightNext = cache.get(rightNextKey);
        } else {
            rightNext = process1(matrix, i, j + 1);
        }
        return matrix[i][j] + Math.min(downNext, rightNext);
    }
    String key = String.valueOf(i) + "_" + String.valueOf(j);
    cache.put(key, result);
    return result;
}
```

### 动态规划

- 傻缓存不考虑父问题与子问题的依赖关系
- 考虑依赖关系就变成了动态规划

- **思路(套路1)：**

  - i和j一旦确定，返回值就确定了。
  - 假设有m行n列-->i从0->m-1变化，j从0->n-1变化
  - i:[0,m-1]，j:[0,n-1]构成一张二维表，这张二维表能装下所有点的信息**(任何一个递归->先写出解空间)**
  - 写解空间：先看递归中哪些参数可以代表解的状态
  - 看下哪个状态是你最终要的状态，本题为[0,0]。(确定目标)
  - 确定目标之后，回到basecase看一看哪个点是不被依赖的
  - 找一个普遍的(i,j)位置，看一看它依赖哪些位置
    - 处于最后一行的(i,j)，只依赖于它右边的位置
      - 从不被依赖的点(m,n)->(i,j)上在表中的点全部能算出来(最后一行全部能算出来)
    - 处于最后一列的(i,j)，只依赖于它下边的位置
      - 同上，最后一列也能全部算出来
    - 除去最后一行和最后一列的其他依赖于下边和右边的(i,j)
      - 从右往左(算行)，从下往上(算列)直到算到(0,0)就是答案。
    - 搭积木-->DP

  

### 题目3

- 给你一个正数数组arr，和一个正数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或false

#### 递归

- 思路：每个位置的值要么包含要么不包含

```java
public static boolean process1(int[] arr,int i,int sum,int aim){

    //base case
    if(i == arr.length){
        return sum == aim;
    }
    return (process1(arr,i+1,sum,aim)
            || process1(arr,i+1,sum+arr[i],aim));
}
```

### dp

- 看参数,参数i和参数sum确定之后返回值就确定了

- 参数i:[0,N],sum:[0,数组的和]
- 目标点(0,0)
- 已知点(basecase)
- 推出最后一行
- 找任意一点i的依赖
- 通过最后一行推出目标点结果



# Day08

**无后效的暴力递归才能改成动态规划**(到达子状态的路径选择不影响子状态的返回值)

- 暴力递归
- 分析可变参数(得到解空间)
- 根据base case 确定初始状态
- 分析一个普遍位置依赖哪些位置
- 根据依赖顺序，逆序求整张解空间表

## 题目一(01背包问题)

- 给定两个数组w和v，两个数组长度相等，w[i]表示第i件商品得重量，v[i]表示第i件商品得价值。
- 给定一个整数bug,要求你挑选得商品重量之和一定不能超过bug，返回满足这个条件下，你能获得的最大价值

```java
package cn.cqu.ccc1z.Day08.zuo;

public class Knapsack {
    public static int maxValue1(int[] weights,int[] values,int bag){
        return process1(weights,values,0,0,bag);
    }

    public static int process1(int[] weights,int[] values,int i,
                               int alreadycost,int bag){
        if(alreadycost > bag){
            return Integer.MIN_VALUE;//返回一个无效值
        }
        if(i == weights.length){
            return 0;
        }
        return Math.max(process1(weights,values,i+1,alreadycost,bag),
                values[i]+process1(weights,values,i+1,alreadycost+weights[i],bag));
    }

    public static int maxValue2(int[] weigihts,int[] values,int bag){
        int[][] dp = new int[values.length+1][bag+1];
        for(int i = values.length - 1;i >=0 ;i--){
            for(int j = bag; j >=0 ;j--){
                dp[i][j] = dp[i+1][j];
                if(j + weigihts[i] <= bag){
                    dp[i][j] = Math.max(dp[i][j],values[i] + dp[i+1][j+weigihts[i]]);
                }
            }
        }
        return dp[0][0];
    }

    public static void main(String[] args) {
        int[] c = { 3, 2, 4, 7 };
        int[] p = { 5, 6, 3, 19 };
        int bag = 11;
        System.out.println(maxValue1(c, p, bag));
        System.out.println(maxValue2(c, p, bag));
    }
}
```

## 汉诺塔问题

- 打印n层汉诺塔从最左边移动到最右边的全部过程
- f(n) = 2f(n-1) + 1 (等比数列)
- n层汉诺塔需要走2^n - 1步

```java
package cn.cqu.ccc1z.Day08.zuo;

/**
 * 汉诺塔
 */
public class Hanoi {
    static int count = 0;
    public static void hanoi(int n){
        if(n>0){
          print(n,"left","right","mid");
        }
        else{
            throw new RuntimeException("e");
        }
    }

    public static void print(int n,String from,String to,String help){
        if(n == 1){
            System.out.println("move" + n + "from" + from +"to" + to);
        }else{
            print(n-1,from,help,to);
            System.out.println("move" + n + "from" + from + "to" + to);
            print(n-1,help,to,from);
        }
        count++;
    }

    public static void main(String[] args) {
        int n = 10;
        hanoi(n);
        System.out.println(count);
    }
}
```

## 题目3

- 打印一个字符串的全部子序列，包括空字符串

**字符串问题往往都是每个字符要或者不要然后全部走一遍**

```java
package cn.cqu.ccc1z.Day08.zuo;

/**
 * 打印一个字符串的全部子序列
 */
public class PrintAllSubsquences {
    public static void printSubsquences(String str){
        char[] chars = str.toCharArray();
        String pre = "";
        print(chars,0,pre);
    }

    public static void print(char[] chars,int index,String pre){
        if(index == chars.length){
            if(!pre.equals("")){
                System.out.println(pre);
            }
            return;
        }
        print(chars,index+1,pre+String.valueOf(chars[index]));
        print(chars,index+1,pre);
    }

    public static void main(String[] args) {
        String str = "abc";
        printSubsquences(str);
    }
}
```

## 题目4

- 打印一个字符串的全部排列
- 思路
  - (0~i-1)固定
  - (i~N-1)的字符都可以放在i位置，(i+1~N-1)的字符任意变换产生的解

- 不去重

```java
package cn.cqu.ccc1z.Day08.zuo;

/**
 * 打印字符串的全排列
 */
public class PrintALLPermutations {
    public static void printAllPermutations(String str){
        char[] chs = str.toCharArray();
        process1(chs,0);
    }

    public static void process1(char[] chs,int index){
        if(index == chs.length){
            System.out.println(String.valueOf(chs));
        }

        for(int j = index ; j<chs.length;j++){
            swap(chs,index,j);
            process1(chs,index+1);
            swap(chs,index,j);
        }
    }

    public static void swap(char[] chs,int index1,int index2){
        char temp = chs[index1];
        chs[index1] = chs[index2];
        chs[index2] = temp;
    }

    public static void main(String[] args) {
        String str = "abc";
        printAllPermutations(str);
    }
}
```

- 去重

```java
public static void process2(char[] chs,int i){
    if(i == chs.length){
        System.out.println(String.valueOf(chs));
    }
    HashSet<Character> set = new HashSet<>();
    for(int j = i ; j< chs.length ;j++){
        if(!set.contains(chs[j])){
            set.add(chs[j]);
            swap(chs,i,j);
            process2(chs,i+1);
        }
    }
}
```

### 题目5

- 母牛每年生一只母牛，新出生的母牛成长三年后页能每年生一只母牛，假设不会死。求N年后，母牛的数量。

$$
F(N) = F(N-1)+F(N-3)	(N>=3)
$$

- F(N-1)：去年的牛
- F(N-3)：三年前的牛

```java
package cn.cqu.ccc1z.Day08.zuo;

public class Cow {
    public static int howMuchCows(int n){
        if(n == 1) return 1;
        if(n == 2) return 2;
        if(n == 3) return 3;
        return howMuchCows(n-1)+howMuchCows(n-3);
    }

    public static void main(String[] args) {
        System.out.println(howMuchCows(6));
    }
}
```

### ★题目6★

- 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。如何实现？

- 思路
  - 先设计一个函数g->得到栈底元素并返回

```java
package cn.cqu.ccc1z.Day08.zuo;

import java.util.Stack;

public class ReverseStackUsingRecursive {
    public static void reverse(Stack<Integer> stack){
        if(stack.isEmpty()){
            return;
        }
        int i = getAndRemoveLastElement(stack);
        reverse(stack);
        stack.push(i);
        
    }
    
    public static int getAndRemoveLastElement(Stack<Integer> stack){
        int result = stack.pop();
        if(stack.isEmpty()){
            return result;
        }else{
            int last = getAndRemoveLastElement(stack);
            stack.push(result);
            return last;
        }
        
    }
}
```

## Day09

### 题目1

- 给定一个数组代表一个容器
- 比如[3,1,2,4]
- 代表0位置是一个宽度为1，高度为3的直方图
- 代表1位置是一个宽度为1，高度为1的直方图
- 代表2位置是一个宽度为1，高度为2的直方图
- 代表3位置是一个快读为1，高度为4的直方图
- 所有直方图的底部都在一条水平线上，且紧靠着
- 把这个图想成一个容器，这个容器可以装3格的水
- 给定一个没有负数的数组arr，返回能装几格水?

**思路**

- 只算当前位置上面能装多少水而不是去算每个波谷能装多少水(突然来个波峰就木了)

$$
min(max_左,max_右)-当前位置高度(减出负数则当前位置装不了水)
$$

**解法**

- 经典解法：每个位置左边遍历一遍右边遍历一遍找到左边最大和右边最大，之中的最小值来减当前高度。O(N^2)-->不得分

- 优化：
  - **预处理数组的技巧（查询一个值很麻烦的问题可以考虑预处理数组）**
  - 例子:
  - 原数组[3,2,4,5,4,3,1]
  - help1[3,3,4,5,5,5,5]
    - 辅助数组的每个位置`i`都代表了原数组从`0`到`i`上的最大值，辅助数组的每一个新进的数就是比较原数组当前数与辅助数组前一个数的大小，大的写进去。
  - help2[1,3,4,5,5,5,5]
    - 原数组从右往左遍历，代表了`i`到`N-1`上的最大值
  - ->O(N)

- 最优解：

  - **双指针**
  - `0位置`和`N-1位置`一定不会留下水
  - 准备两个指针，left指向1位置,right指向N-2位置
  - 准备两个变量max左，max右

  - max左代表left之前的最大值
  - max右代表right之后的最大值

```java
package cn.cqu.ccc1z.Day08.zuo;

public class Water {
    public static int mostContain(int[] arr) {
        int maxLeft = arr[0];
        int maxRight = arr[arr.length-1];
        int left = 1;
        int right = arr.length - 2;
        int res = 0;
        while (true) {
            if (left != right) {
                if (maxLeft <= maxRight) {
                    if (maxLeft - arr[left] > 0) {
                        res += maxLeft - arr[left];
                    } else {
                        res += 0;
                        maxLeft = arr[left];
                    }
                    left++;
                } else {
                    if (maxRight - arr[right] > 0) {
                        res += maxRight - arr[right];
                    } else {
                        res += 0;
                        maxRight = arr[right];
                    }
                    right--;
                }
            }else{
                int dif = Math.min(maxLeft,maxRight) - arr[left];
                if(dif > 0){
                    res += dif;
                    break;

                }else{
                    res += 0;
                    break;
                }
            }
        }

        return res;
    }

    public static void main(String[] args) {
        int[] arr = {3, 1, 2, 4};
        System.out.println(mostContain(arr));
    }
}
```

### 题目2

- 给定一个数组arr，返回所有子数组的累加和中最大的累加和
  - 子数组是下标连续的数组(0~0 0~1 0~2 .. 0~n-1/1~1,1~2,1~3...1~n-1... 一个N^2个子数组)

**算法流程**

- 准备两个数`cur = 0`,`max = 系统最小`

- max = max(max,cur += 下一个数)
- cur += 下一个数 = 负数，cur变为0

**解释算法流程**(证明没有正数的时候是对的，证明有正数的时候是对的)(算了)

```java
package cn.cqu.ccc1z.Day08.zuo;

public class GetMaxSumSubarr {
    public static int getMax(int[] arr){
        int cur = 0;
        int max = Integer.MIN_VALUE;
        for(int i = 0 ; i < arr.length ;i++){
            cur += arr[i];
            max = Math.max(cur,max);
            cur = cur < 0 ? 0 : cur;
        }
        return max;
    }

    public static void main(String[] args) {
        int[] arr = {0,0,3,4};
        System.out.println(getMax(arr));
    }
}
```

### 题目3

- 想想一个字符串其实是一个循环数组，可以循环右移
- 比如"abc"
- 向右循环右移一位，得到"cab"
- 向右循环右移两位，得到"bca"
- 向右循环右移三位，得到"abc"
- 给定两个字符串str1和str2，判断str2是不是由str1循环右移得到的

**算法流程**

- str1 str2
- 先判断长度是否相等
- 长度相等生成 str1+str1，如果包含str2,那么true否则false(KMP算法判断是否包含子串)

```java
package cn.cqu.ccc1z.Day08.zuo;

/**
 * 判断循环字符串
 */
public class IsStringCycle {
    public static boolean isCycle(String str1,String str2){
        if(str1.length() != str2.length()) return false;
        String str = str1.concat(str1);
        return str.indexOf(str2) > 0;
    }

    public static void main(String[] args) {
        String str1 = "abc";
        String str2 = "baa";

        System.out.println(isCycle(str1,str2));
    }
}
```

### 题目4

- 给定一个字符串str，和一个整数k，返回str向右循环右移k位后的结果

**算法流程**

- [1,2,3,4,5]	3	output:[3,4,5,1,2]
- 分成两个部分左边[1,2]右边[3,4,5]
- 左边逆序右边逆序[2,1,5,4,3]
- 整体逆序[3,4,5,1,2]

```java
package cn.cqu.ccc1z.Day08.zuo;

public class StringCycle {
    public static String stringCycle(String str,int n){
        char[] chs = str.toCharArray();
        int p = n-1;
        int left = 0;
        int right = chs.length-1;
        while(left != p){
            //左边逆序
            swap(chs,left,p-1);
            left++;
            p--;
        }
        p = n-1;
        while(p != right){
            //右边逆序
            swap(chs,p,right);
            p++;
            right--;
        }
        left = 0;
        right = chs.length-1;
        while(left != right){
            //整体逆序
            swap(chs,left,right);
            left++;
            right--;
        }
        return new String(chs);
    }

    public static void swap(char[] chs,int index1,int index2){
        char temp = chs[index1];
        chs[index1] = chs[index2];
        chs[index2] = temp;
    }

    public static void main(String[] args) {
        String str = "12345";
        String res = stringCycle(str, 3);
        System.out.println(res);
    }
}
```

### 题目5-生成窗口最大值数组

- 由一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置
- 例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时
  - [4,3,4] 4 3 3 6 7 窗口中最大值为5
  - 4 [3 5 4] 3 3 6 7 窗口中最大值是5
  - 4 3 [5 4 3] 3 6 7 窗口中最大值是5
  - 4 3 5 [4 3 3] 6 7 窗口中最大值是4
  - 4 3 5 4 [3 3 6] 7 窗口中最大值为6
  - 4 3 5 4 3 [3 6 7] 窗口中最大值为7
- 如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值
- 请实现一个函数：
  - 输入：整型数组arr，窗口大小为w
  - 输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值
  - 以本例为例返回[5,5,5,4,6,7]

**一个重要的数据结构--被火车撞了也不能忘的**

- **窗口内最大(小)值的更新结构--双端队列**
  - 构建窗口：`int L,R = -1`
    - `L-R窗口的加数逻辑`：
      - 每加一个数`R`向右移动一位，只能向前走，不能退
    - `L-R窗口的减数逻辑`：
      - `L`往右走，每走一位窗口减掉一个数
    - `L`永远在`R`的左边
  - 窗口更新时怎么快速得到窗口的最大(小)值--***双端队列(可以从头部进(出)可以从尾部进(出)***
    - 双向链表实现双端队列
    - 让双端队列`从头部到尾部是从大到小`的
- 双端队列加数逻辑：
  - 窗口中的数进入双端队列如果不改变`从小到大的顺序`就从尾部进
    - 如果要改变`从小到大的顺序`就从尾部依次弹出，直到不改变从小到大的顺序或者队列为空，这个数进双端队列**（相等也弹出，必须严格从小到大，错误，相等入列才对，要不然数组中有相等元素的时候会出现错误)**
    - 该双端队列的头节点就是窗口的最大值

- 双端队列减数逻辑：
  - `L`右移窗口出数的时候，先看出去的数是不是头节点的数
    - 是头节点，从头部弹出
    - 不是头节点，不动

```java
package cn.cqu.ccc1z.Day08.zuo;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;

public class MaxSlidingWindow {
    public static int[] getMaxSlidWindowArr(int[] arr,int len){
        int left = -1;
        int right = -1;
        int[] res = new int[arr.length-len+1];
        int i = 0;
        Deque<Integer> dq = new LinkedList<>();
        while(right != len-1){
            enterDeque(dq,arr[++right]);
        }
        left = 0;
        while(true){
            res[i++] = dq.peekFirst();
            if(right == arr.length-1){
                break;
            }
            pollDeque(dq,arr[left++]);
            enterDeque(dq,arr[++right]);
            int size = right-left+1;
        }
        return res;
    }

    public static void enterDeque(Deque<Integer> dq,int n){
        if(dq.isEmpty() || n <= dq.peekLast()){
            dq.addLast(n);
        }else{
            while(!dq.isEmpty() && dq.peekLast() < n){
                dq.pollLast();
            }
            dq.addLast(n);
        }
    }

    public static void pollDeque(Deque<Integer> dq,int n){
        if(n == dq.peekFirst()){
            dq.pollFirst();
        }else{
            return;
        }
    }

    public static void main(String[] args) {
        int[] arr = {-7,-8,7,5,7,1,6,0};
        System.out.println(Arrays.toString(getMaxSlidWindowArr(arr,4)));
    }
}
```